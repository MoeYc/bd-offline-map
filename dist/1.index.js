(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./src/DrawingManager.min.js":
/*!***********************************!*\
  !*** ./src/DrawingManager.min.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* eslint-disable */\r\n/**\r\n * @fileoverview 百度地图的鼠标绘制工具，对外开放。\r\n * 允许用户在地图上点击完成鼠标绘制的功能。\r\n * 使用者可以自定义所绘制结果的相关样式，例如线宽、颜色、测线段距离、面积等等。\r\n * 主入口类是<a href=\"symbols/BMapGLLib.DrawingManager.html\">DrawingManager</a>，\r\n * 基于Baidu Map API GL 1.0。\r\n *\r\n * @author Baidu Map Api Group\r\n * @version 1.0\r\n */\r\n\r\n/**\r\n * @namespace BMapGL的所有library类均放在BMapGLLib命名空间下\r\n */\r\n\r\nvar BMapGLLib = window.BMapGLLib = BMapGLLib || {};\r\nwindow.BMapLib = BMapGLLib\r\n/**\r\n * 定义常量, 绘制的模式\r\n * @final {Number} DrawingType\r\n */\r\nvar BMAP_DRAWING_MARKER = \"marker\",     // 鼠标画点模式\r\n    BMAP_DRAWING_POLYLINE = \"polyline\",   // 鼠标画线模式\r\n    BMAP_DRAWING_CIRCLE = \"circle\",     // 鼠标画圆模式\r\n    BMAP_DRAWING_RECTANGLE = \"rectangle\",  // 鼠标画矩形模式\r\n    BMAP_DRAWING_POLYGON = \"polygon\";    // 鼠标画多边形模式\r\n\r\n(function () {\r\n\r\n    var circlePng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAAXNSR0IArs4c6QAAAs1JREFUWAnNmb9v01AQx989SzVI8dIBJNZ27Mb/QRpExMiOKAW1Mw3MRVCB2BlRECF/CBtjuwbBwGJL1JXs474vtuU4Tkho4tyTGr9ffvfxvV93VzL/mfYPLndSumqT4buG6Y4MI3+MpyQayc/IEI/Y0DfLW8Ov725cuKYlf2iZ/p3j8FZylT4hQx1m3lvmXSL6zoYH3pZ9PzgNfi367kKA3R634t/REXF6zMa0Fh28rp8IjJjsqb/det3vUVTXp1z3T8DOs/B+kvIHw3y7/OK180Q/PUuPB2+DL/PGsrMaZQrp3tPwJEn488rhIFQ+GGNDBmTN4qht6D7nm3ESfpRBurNeXGk9Ud/3gkf9N/SnOu6UBvE1jcKBSBQBmXWanAJsH0YvGtNcWV0C6WSX6yQ/McVuQ2DNycFW6ddQkdjz6EF54xQg46MkPMfibYimXozsbn872M2PoGKKcc5tHA7IoiDHkuE7DeKGSOP04rqHcL1Klq8VqMj6dgc3jtMgx+mBFjh8DlhwpSI/BiTaR0FTwn0PHnJWiYnPNcHlLNb4uxYmU16h7Qk26+w5bWQZD9hsZmzqRBRDGJsks4JVMgIwN9M1ArIAykRrRHNMwoY1+EMtoLBhDcID05pGMsWsF1DYLPxWrepzPjWcaq2AYLPw+OFUa4MEE9jG1ox4/NoAEYUAkwNEOAJGohZIsICpAITlinCEFkCw5PEbp0GAIVZixGHZOKRzmoQlSwUgvCjESsSG3eDVJ26nMOQeHRgLQBScP0r0EvmNJJFd9onBIOtxMiH80D4MPzUeXZD4zPAseCjHy8QMTmgQqOiAQI5k+pPoayxlwaMqnOOZJXasSRenOVlfKES0JdM6PGu9qoObC5iDqw1g5oBYtIiVGLK9VRzmbgwZC2NWN0Qus/yc2iTlxmoeIRIXhRBHX5bAXrV9XlmmcH1B9DrBTf0b4i99lUEMOuku/wAAAABJRU5ErkJggg==';\r\n    var bulletPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAd9JREFUOBGtVc8rRFEUPufOvELMguTHwkbKjxRlo9gqNpjyFyhTit3I8i1ldpQa5S9QmA1lS9koSn6UZmMxSCyGkPlx3O+9mTe8Zl4zw7eZ7rnn++aee893HlMRzEXFeLh6m2LJTpHwEJG022mcIJZTYbXX2lu/txnilJvO7sDkYnJaC0REqNO993PNTHEiDsfWAru/4vmFaYo6e35dEZIwYh1tPhobNmig20/NjcpKe3rJ0vlNmg5PUnR3n7FiTBwZbGpYNk3OIuCccHIhuQoxv49lNljD4yMG6VMUhT49HRynaGvnU9IZ0Wkcia0HlhxBlCkiOxAz5+u4v8tXVMgdvLjNkLnxbosyB1E+4wEeL5PXuLPQTC1NjBpunud6/yhF0e0PVBNv6Qv0KLwmxHBnKLNSgAMuNKClrNbQKniAUnfm9SfggAtAS9l9RtZrehG99tAJFnTP6n6wmzbfGl7EUnsFrrTbDVYqs4q4FtR20kDTVosClxMK3oQQHFAtHK7WUjA6hGAnOKBSgAMuAC2FqYGmhDdhp0oBDrjQgJayRxBbAwHehJ3KBXLBsfM5DC3H/v81HHIdSYQRpMcX6ekRhjcPjr/KGV+6Unt8xXJlOSfMl/lvAzYviN+/fAK+AW5jAVefzjWGAAAAAElFTkSuQmCC';\r\n    var nbPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAABcdJREFUeAHtm0FoHFUYx7+ZbDfJJiZUqcEgBU3BqtGKRdGLHsSTSGxL8agUT230YtGTDQl6EKt4CD1JqPQkastSPImIvVSUQINRK1jrQVNSRRGz3WST3fH/f5k3THY3mmzejLub74Mv8/bNzJv3fnwz773v+yKiogSUgBJQAkpACSgBJaAElIASUAJKQAkoASWgBJSAElACSkAJKIH2J+A1OsQgCIZw7wh0P3Qwpr0oN7MsoHNzMZ1GOe953pVGOr0pgIB2Kx4yCj0AHW7kgU18zyz6dg46CZjXN9rPDQEEOFrVy9DjUGNhhaIEX8+WvEuXy/LbnxX5468AWpHF0kYf/f9c190psrPPl5v7Pdm105cH9nbIQ8PZoKdbLAta6Eno2wDJ8r+KvWndiwDvIE6egg7wooszy/LJhZJ8e6UslQprWl98X+TeoQ556rGsPLpvhx3QPApHAfGsrah3XBcgwPHcCegY1Pv+pxU5nV+Sy1fL9dppm7q9d3TI8yOdcvedGY4pgI5DJwCS5RqpCxDwunHl+9DDlUCCqbOL3vkvmvzdrBna1iqefjwrRw52Bb5nXu0P0dpzgFisbrUGYGh5H+DCw4ViELw5dcOb+aG9ra4aiv29764OefVIDt9Hj5wI8dlqS8TbXyN8bQ28V94pbFt4pELDIQMaEplAyWaNrAEYThhjfG1peb/Mt8kssWbIm/tBBmRBJrhzLGQUNRIBxAkuTzjbevzmbdfXNiITK5AFmZAN9FTIylwRAcQvrvMGONtutwnDkPiPP2RCNmQEJSsjBiCIcofBRbJZqpgzjv88cn8GC1azNHDW8qEns7L7trgNOGu6bkNcxoVyPGQm9ukv4kQvF8lJrfN6cx5mtG6nEG/p9+X10VxqEMmGjMgKOsqCBfgMf3CHkZQsw/p3ZNxCLOPL3n9TuhBjjOgPEB+mSK/KMPe23J4lJdPfLcvfhcApxM++XJZyOV2IZERWZEZ2tEC6pOSrb0peknvbhRsir00WnEL8ea4ib50upgqRjMiKzCAjBEh/nlxKYbdx9deKc4gXZ1ZShxhb4u0nQDpD5Xe4pNKQdoBI910ogxFA+vPSklaHGGMVBxhRTYVjK0Ok4zgUA9CYnvE32OqUjoSIfaZ5ml3i3D7Al6Jx4TfRLni5xJk4lpPObOPt1bszxipgb6/xIrq50xa40eG87Ioem/+8JFt1YAzu8uXAE6vEuE6cOrcoS46XtzFW10iNESoTI4hGkkKB8CaO9cie3R3maR99uiRnzkdbpYZ6QHhvvJTDWHwhvHfPFOXCtNm/NtTeejcxnhLKXASQAZa0pJXhkVGMlQHIuKjQ+5qGtDo8MmIkL5Rpml2ePx6+LxswOpWktAM8MmIYNOSU9+HjZ0R+FoPzGNpLSjJo2vU3r6/XS+WbF2dCRmRFZmRnbY4ReRMXjV/ssvzgPRmnEwb7xshZ0hNGNQPGjkMxzCzASVQuMKjMuGgS0tezOnO5mG1t/xAtS3S2tc+xR7IJA+/MWCCzVX8gTJG5IExnMEFlHl0L41ou4bF/SS5V6o2fAfdQTobMonwQgW+LXtYfoQPvfbzoPC6SgTd/xfGSLIssjJJxENtxJXfk5+KFQ2bRP4+n7AFAWmHkkZaw4ijqAkbkXS9rXMNj59OCRxZkQjZQ5ssYeOyD/QayTIhMpBlnOgMj8lvdl5pGW/wPGZBFmOIxHjKKRhXtSWwNXmXWaWoHIGwktaMGIEECInaqmlzUUHIRAVJCSzyB4hhU09s2k95GgFYAUhMsLYw6x7qvcPV1gMglTk2KL6NTDEYxntIqKb5d2Ehw92JTfPmdox8g3J5x6JxhuSZ2k+LLFq0AJFNAmMXAQPywrW+T4yzGkUySeT1AgDmEesaUGRZlZM8qrbWZhRZGJ7LVLf2bQzMPVPumBJSAElACSkAJKAEloASUgBJQAkpACSgBJaAElIASUAJKQAkoAVcE/gG4Wba8Vno8+QAAAABJRU5ErkJggg==';\r\n\r\n    function mercatorToLnglat(mercatorx, mercatory){\r\n        \r\n        let x = mercatorx/20037508.34*180;\r\n        let y = mercatory/20037508.34*180;\r\n        \r\n        y= 180/Math.PI*(2*Math.atan(Math.exp(y*Math.PI/180))-Math.PI/2);\r\n        return [x, y]\r\n    };\r\n    function lnglatToMercator(lon, lat){\r\n        \r\n        let x = lon * 20037508.34 / 180;\r\n        let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);\r\n        \r\n        y = y * 20037508.34 / 180;\r\n        \r\n        return [x, y];\r\n    }\r\n    /**\r\n     * 声明baidu包\r\n     */\r\n    var baidu = baidu || { guid: '$BAIDU$' };\r\n    // 用来存储用户实例化出来的drawingmanager对象\r\n    var instances = [];\r\n    (function () {\r\n        // 一些页面级别唯一的属性，需要挂载在window[baidu.guid]上\r\n        window[baidu.guid] = {};\r\n\r\n        /**\r\n         * 将源对象的所有属性拷贝到目标对象中\r\n         * @name baidu.extend\r\n         * @function\r\n         * @grammar baidu.extend(target, source)\r\n         * @param {Object} target 目标对象\r\n         * @param {Object} source 源对象\r\n         * @returns {Object} 目标对象\r\n         */\r\n        baidu.extend = function (target, source) {\r\n            for (var p in source) {\r\n                if (source.hasOwnProperty(p)) {\r\n                    target[p] = source[p];\r\n                }\r\n            }\r\n            return target;\r\n        };\r\n\r\n        /**\r\n         * @ignore\r\n         * @namespace\r\n         * @baidu.lang 对语言层面的封装，包括类型判断、模块扩展、继承基类以及对象自定义事件的支持。\r\n         * @property guid 对象的唯一标识\r\n         */\r\n        baidu.lang = baidu.lang || {};\r\n\r\n        /**\r\n         * 返回一个当前页面的唯一标识字符串。\r\n         * @function\r\n         * @grammar baidu.lang.guid()\r\n         * @returns {String} 当前页面的唯一标识字符串\r\n         */\r\n        baidu.lang.guid = function () {\r\n            return 'TANGRAM__' + (window[baidu.guid]._counter++).toString(36);\r\n        };\r\n\r\n        window[baidu.guid]._counter = window[baidu.guid]._counter || 1;\r\n\r\n        /**\r\n         * 所有类的实例的容器\r\n         * key为每个实例的guid\r\n         */\r\n        window[baidu.guid]._instances = window[baidu.guid]._instances || {};\r\n\r\n        /**\r\n         * Tangram继承机制提供的一个基类，用户可以通过继承baidu.lang.Class来获取它的属性及方法。\r\n         * @function\r\n         * @name baidu.lang.Class\r\n         * @grammar baidu.lang.Class(guid)\r\n         * @param {string} guid 对象的唯一标识\r\n         * @meta standard\r\n         * @remark baidu.lang.Class和它的子类的实例均包含一个全局唯一的标识guid。\r\n         * guid是在构造函数中生成的，因此，继承自baidu.lang.Class的类应该直接或者间接调用它的构造函数。<br>\r\n         * baidu.lang.Class的构造函数中产生guid的方式可以保证guid的唯一性，及每个实例都有一个全局唯一的guid。\r\n         */\r\n        baidu.lang.Class = function (guid) {\r\n            this.guid = guid || baidu.lang.guid();\r\n            window[baidu.guid]._instances[this.guid] = this;\r\n        };\r\n\r\n        window[baidu.guid]._instances = window[baidu.guid]._instances || {};\r\n\r\n        /**\r\n         * 判断目标参数是否string类型或String对象\r\n         * @name baidu.lang.isString\r\n         * @function\r\n         * @grammar baidu.lang.isString(source)\r\n         * @param {Any} source 目标参数\r\n         * @shortcut isString\r\n         * @meta standard\r\n         *\r\n         * @returns {boolean} 类型判断结果\r\n         */\r\n        baidu.lang.isString = function (source) {\r\n            return '[object String]' == Object.prototype.toString.call(source);\r\n        };\r\n\r\n        /**\r\n         * 判断目标参数是否为function或Function实例\r\n         * @name baidu.lang.isFunction\r\n         * @function\r\n         * @grammar baidu.lang.isFunction(source)\r\n         * @param {Any} source 目标参数\r\n         * @returns {boolean} 类型判断结果\r\n         */\r\n        baidu.lang.isFunction = function (source) {\r\n            return '[object Function]' == Object.prototype.toString.call(source);\r\n        };\r\n\r\n        /**\r\n         * 重载了默认的toString方法，使得返回信息更加准确一些。\r\n         * @return {string} 对象的String表示形式\r\n         */\r\n        baidu.lang.Class.prototype.toString = function () {\r\n            return '[object ' + (this._className || 'Object') + ']';\r\n        };\r\n\r\n        /**\r\n         * 释放对象所持有的资源，主要是自定义事件。\r\n         * @name dispose\r\n         * @grammar obj.dispose()\r\n         */\r\n        baidu.lang.Class.prototype.dispose = function () {\r\n            delete window[baidu.guid]._instances[this.guid];\r\n            for (var property in this) {\r\n                if (!baidu.lang.isFunction(this[property])) {\r\n                    delete this[property];\r\n                }\r\n            }\r\n            this.disposed = true;\r\n        };\r\n\r\n        /**\r\n         * 自定义的事件对象。\r\n         * @function\r\n         * @name baidu.lang.Event\r\n         * @grammar baidu.lang.Event(type[, target])\r\n         * @param {string} type  事件类型名称。为了方便区分事件和一个普通的方法，事件类型名称必须以\"on\"(小写)开头。\r\n         * @param {Object} [target]触发事件的对象\r\n         * @meta standard\r\n         * @remark 引入该模块，会自动为Class引入3个事件扩展方法：addEventListener、removeEventListener和dispatchEvent。\r\n         * @see baidu.lang.Class\r\n         */\r\n        baidu.lang.Event = function (type, target) {\r\n            this.type = type;\r\n            this.returnValue = true;\r\n            this.target = target || null;\r\n            this.currentTarget = null;\r\n        };\r\n\r\n        /**\r\n         * 注册对象的事件监听器。引入baidu.lang.Event后，Class的子类实例才会获得该方法。\r\n         * @grammar obj.addEventListener(type, handler[, key])\r\n         * @param   {string}   type         自定义事件的名称\r\n         * @param   {Function} handler      自定义事件被触发时应该调用的回调函数\r\n         * @param   {string}   [key]        为事件监听函数指定的名称，可在移除时使用。如果不提供，方法会默认为它生成一个全局唯一的key。\r\n         * @remark  事件类型区分大小写。如果自定义事件名称不是以小写\"on\"开头，该方法会给它加上\"on\"再进行判断，即\"click\"和\"onclick\"会被认为是同一种事件。 \r\n         */\r\n        baidu.lang.Class.prototype.addEventListener = function (type, handler, key) {\r\n            if (!baidu.lang.isFunction(handler)) {\r\n                return;\r\n            }\r\n            !this.__listeners && (this.__listeners = {});\r\n            var t = this.__listeners,\r\n                id;\r\n            if (typeof key == 'string' && key) {\r\n                if (/[^\\w\\-]/.test(key)) {\r\n                    throw ('nonstandard key:' + key);\r\n                } else {\r\n                    handler.hashCode = key;\r\n                    id = key;\r\n                }\r\n            }\r\n\r\n            type.indexOf('on') != 0 && (type = 'on' + type);\r\n            typeof t[type] != 'object' && (t[type] = {});\r\n            id = id || baidu.lang.guid();\r\n            handler.hashCode = id;\r\n            t[type][id] = handler;\r\n        };\r\n\r\n        /**\r\n         * 移除对象的事件监听器。引入baidu.lang.Event后，Class的子类实例才会获得该方法。\r\n         * @grammar obj.removeEventListener(type, handler)\r\n         * @param {string}   type     事件类型\r\n         * @param {Function|string} handler  要移除的事件监听函数或者监听函数的key\r\n         * @remark  如果第二个参数handler没有被绑定到对应的自定义事件中，什么也不做。\r\n         */\r\n        baidu.lang.Class.prototype.removeEventListener = function (type, handler) {\r\n            if (baidu.lang.isFunction(handler)) {\r\n                handler = handler.hashCode;\r\n            } else if (!baidu.lang.isString(handler)) {\r\n                return;\r\n            }\r\n            !this.__listeners && (this.__listeners = {});\r\n            type.indexOf('on') != 0 && (type = 'on' + type);\r\n            var t = this.__listeners;\r\n            if (!t[type]) {\r\n                return;\r\n            }\r\n            t[type][handler] && delete t[type][handler];\r\n        };\r\n\r\n        /**\r\n         * 派发自定义事件，使得绑定到自定义事件上面的函数都会被执行。引入baidu.lang.Event后，Class的子类实例才会获得该方法。\r\n         * @grammar obj.dispatchEvent(event, options)\r\n         * @param {baidu.lang.Event|String} event   Event对象，或事件名称(1.1.1起支持)\r\n         * @param {Object} options 扩展参数,所含属性键值会扩展到Event对象上(1.2起支持)\r\n         * @remark 处理会调用通过addEventListenr绑定的自定义事件回调函数之外，还会调用直接绑定到对象上面的自定义事件。\r\n         * 例如：<br>\r\n         * myobj.onMyEvent = function(){}<br>\r\n         * myobj.addEventListener(\"onMyEvent\", function(){});\r\n         */\r\n        baidu.lang.Class.prototype.dispatchEvent = function (event, options) {\r\n            if (baidu.lang.isString(event)) {\r\n                event = new baidu.lang.Event(event);\r\n            }\r\n            !this.__listeners && (this.__listeners = {});\r\n            options = options || {};\r\n            for (var i in options) {\r\n                event[i] = options[i];\r\n            }\r\n            var i,\r\n                t = this.__listeners,\r\n                p = event.type;\r\n            event.target = event.target || this;\r\n            event.currentTarget = this;\r\n            p.indexOf('on') != 0 && (p = 'on' + p);\r\n            baidu.lang.isFunction(this[p]) && this[p].apply(this, arguments);\r\n            if (typeof t[p] == 'object') {\r\n                for (i in t[p]) {\r\n                    t[p][i].apply(this, arguments);\r\n                }\r\n            }\r\n            return event.returnValue;\r\n        };\r\n\r\n        /**\r\n         * 为类型构造器建立继承关系\r\n         * @name baidu.lang.inherits\r\n         * @function\r\n         * @grammar baidu.lang.inherits(subClass, superClass[, className])\r\n         * @param {Function} subClass 子类构造器\r\n         * @param {Function} superClass 父类构造器\r\n         * @param {string} className 类名标识\r\n         * @remark 使subClass继承superClass的prototype，\r\n         * 因此subClass的实例能够使用superClass的prototype中定义的所有属性和方法。<br>\r\n         * 这个函数实际上是建立了subClass和superClass的原型链集成，并对subClass进行了constructor修正。<br>\r\n         * <strong>注意：如果要继承构造函数，需要在subClass里面call一下，具体见下面的demo例子</strong>\r\n         * @shortcut inherits\r\n         * @meta standard\r\n         * @see baidu.lang.Class\r\n         */\r\n        baidu.lang.inherits = function (subClass, superClass, className) {\r\n            var key,\r\n                proto,\r\n                selfProps = subClass.prototype,\r\n                clazz = new Function();\r\n            clazz.prototype = superClass.prototype;\r\n            proto = subClass.prototype = new clazz();\r\n            for (key in selfProps) {\r\n                proto[key] = selfProps[key];\r\n            }\r\n            subClass.prototype.constructor = subClass;\r\n            subClass.superClass = superClass.prototype;\r\n\r\n            if ('string' == typeof className) {\r\n                proto._className = className;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @ignore\r\n         * @namespace baidu.dom 操作dom的方法。\r\n         */\r\n        baidu.dom = baidu.dom || {};\r\n\r\n        /**\r\n         * 从文档中获取指定的DOM元素\r\n         *\r\n         * @param {string|HTMLElement} id 元素的id或DOM元素\r\n         * @meta standard\r\n         * @return {HTMLElement} DOM元素，如果不存在，返回null，如果参数不合法，直接返回参数\r\n         */\r\n        baidu._g = baidu.dom._g = function (id) {\r\n            if (baidu.lang.isString(id)) {\r\n                return document.getElementById(id);\r\n            }\r\n            return id;\r\n        };\r\n\r\n        /**\r\n         * 从文档中获取指定的DOM元素\r\n         * @name baidu.dom.g\r\n         * @function\r\n         * @grammar baidu.dom.g(id)\r\n         * @param {string|HTMLElement} id 元素的id或DOM元素\r\n         * @meta standard\r\n         *\r\n         * @returns {HTMLElement|null} 获取的元素，查找不到时返回null,如果参数不合法，直接返回参数\r\n         */\r\n        baidu.g = baidu.dom.g = function (id) {\r\n            if ('string' == typeof id || id instanceof String) {\r\n                return document.getElementById(id);\r\n            } else if (id && id.nodeName && (id.nodeType == 1 || id.nodeType == 9)) {\r\n                return id;\r\n            }\r\n            return null;\r\n        };\r\n\r\n        /**\r\n         * 在目标元素的指定位置插入HTML代码\r\n         * @name baidu.dom.insertHTML\r\n         * @function\r\n         * @grammar baidu.dom.insertHTML(element, position, html)\r\n         * @param {HTMLElement|string} element 目标元素或目标元素的id\r\n         * @param {string} position 插入html的位置信息，取值为beforeBegin,afterBegin,beforeEnd,afterEnd\r\n         * @param {string} html 要插入的html\r\n         * @remark\r\n         *\r\n         * 对于position参数，大小写不敏感<br>\r\n         * 参数的意思：beforeBegin&lt;span&gt;afterBegin   this is span! beforeEnd&lt;/span&gt; afterEnd <br />\r\n         * 此外，如果使用本函数插入带有script标签的HTML字符串，script标签对应的脚本将不会被执行。\r\n         *\r\n         * @shortcut insertHTML\r\n         * @meta standard\r\n         *\r\n         * @returns {HTMLElement} 目标元素\r\n         */\r\n        baidu.insertHTML = baidu.dom.insertHTML = function (element, position, html) {\r\n            element = baidu.dom.g(element);\r\n            var range,\r\n                begin;\r\n\r\n            if (element.insertAdjacentHTML) {\r\n                element.insertAdjacentHTML(position, html);\r\n            } else {\r\n                // 这里不做\"undefined\" != typeof(HTMLElement) && !window.opera判断，其它浏览器将出错？！\r\n                // 但是其实做了判断，其它浏览器下等于这个函数就不能执行了\r\n                range = element.ownerDocument.createRange();\r\n                // FF下range的位置设置错误可能导致创建出来的fragment在插入dom树之后html结构乱掉\r\n                // 改用range.insertNode来插入html, by wenyuxiang @ 2010-12-14.\r\n                position = position.toUpperCase();\r\n                if (position == 'AFTERBEGIN' || position == 'BEFOREEND') {\r\n                    range.selectNodeContents(element);\r\n                    range.collapse(position == 'AFTERBEGIN');\r\n                } else {\r\n                    begin = position == 'BEFOREBEGIN';\r\n                    range[begin ? 'setStartBefore' : 'setEndAfter'](element);\r\n                    range.collapse(begin);\r\n                }\r\n                range.insertNode(range.createContextualFragment(html));\r\n            }\r\n            return element;\r\n        };\r\n\r\n        /**\r\n         * 为目标元素添加className\r\n         * @name baidu.dom.addClass\r\n         * @function\r\n         * @grammar baidu.dom.addClass(element, className)\r\n         * @param {HTMLElement|string} element 目标元素或目标元素的id\r\n         * @param {string} className 要添加的className，允许同时添加多个class，中间使用空白符分隔\r\n         * @remark\r\n         * 使用者应保证提供的className合法性，不应包含不合法字符，className合法字符参考：http://www.w3.org/TR/CSS2/syndata.html。\r\n         * @shortcut addClass\r\n         * @meta standard\r\n         *\r\n         * @returns {HTMLElement} 目标元素\r\n         */\r\n        baidu.ac = baidu.dom.addClass = function (element, className) {\r\n            element = baidu.dom.g(element);\r\n            var classArray = className.split(/\\s+/),\r\n                result = element.className,\r\n                classMatch = ' ' + result + ' ',\r\n                i = 0,\r\n                l = classArray.length;\r\n\r\n            for (; i < l; i++) {\r\n                if (classMatch.indexOf(' ' + classArray[i] + ' ') < 0) {\r\n                    result += (result ? ' ' : '') + classArray[i];\r\n                }\r\n            }\r\n\r\n            element.className = result;\r\n            return element;\r\n        };\r\n\r\n        /**\r\n         * @ignore\r\n         * @namespace baidu.event 屏蔽浏览器差异性的事件封装。\r\n         * @property target     事件的触发元素\r\n         * @property pageX      鼠标事件的鼠标x坐标\r\n         * @property pageY      鼠标事件的鼠标y坐标\r\n         * @property keyCode    键盘事件的键值\r\n         */\r\n        baidu.event = baidu.event || {};\r\n\r\n        /**\r\n         * 事件监听器的存储表\r\n         * @private\r\n         * @meta standard\r\n         */\r\n        baidu.event._listeners = baidu.event._listeners || [];\r\n\r\n        /**\r\n         * 为目标元素添加事件监听器\r\n         * @name baidu.event.on\r\n         * @function\r\n         * @grammar baidu.event.on(element, type, listener)\r\n         * @param {HTMLElement|string|window} element 目标元素或目标元素id\r\n         * @param {string} type 事件类型\r\n         * @param {Function} listener 需要添加的监听器\r\n         * @remark\r\n         *  1. 不支持跨浏览器的鼠标滚轮事件监听器添加<br>\r\n         *  2. 改方法不为监听器灌入事件对象，以防止跨iframe事件挂载的事件对象获取失败\r\n         * @shortcut on\r\n         * @meta standard\r\n         * @see baidu.event.un\r\n         *\r\n         * @returns {HTMLElement|window} 目标元素\r\n         */\r\n        baidu.on = baidu.event.on = function (element, type, listener) {\r\n            type = type.replace(/^on/i, '');\r\n            element = baidu._g(element);\r\n            var realListener = function (ev) {\r\n                // 1. 这里不支持EventArgument,  原因是跨frame的事件挂载\r\n                // 2. element是为了修正this\r\n                listener.call(element, ev);\r\n            },\r\n                lis = baidu.event._listeners,\r\n                filter = baidu.event._eventFilter,\r\n                afterFilter,\r\n                realType = type;\r\n            type = type.toLowerCase();\r\n            // filter过滤\r\n            if (filter && filter[type]) {\r\n                afterFilter = filter[type](element, type, realListener);\r\n                realType = afterFilter.type;\r\n                realListener = afterFilter.listener;\r\n            }\r\n\r\n            // 事件监听器挂载\r\n            if (element.addEventListener) {\r\n                element.addEventListener(realType, realListener, false);\r\n            } else if (element.attachEvent) {\r\n                element.attachEvent('on' + realType, realListener);\r\n            }\r\n\r\n            // 将监听器存储到数组中\r\n            lis[lis.length] = [element, type, listener, realListener, realType];\r\n            return element;\r\n        };\r\n\r\n        /**\r\n         * 为目标元素移除事件监听器\r\n         * @name baidu.event.un\r\n         * @function\r\n         * @grammar baidu.event.un(element, type, listener)\r\n         * @param {HTMLElement|string|window} element 目标元素或目标元素id\r\n         * @param {string} type 事件类型\r\n         * @param {Function} listener 需要移除的监听器\r\n         * @shortcut un\r\n         * @meta standard\r\n         *\r\n         * @returns {HTMLElement|window} 目标元素\r\n         */\r\n        baidu.un = baidu.event.un = function (element, type, listener) {\r\n            element = baidu._g(element);\r\n            type = type.replace(/^on/i, '').toLowerCase();\r\n\r\n            var lis = baidu.event._listeners,\r\n                len = lis.length,\r\n                isRemoveAll = !listener,\r\n                item,\r\n                realType,\r\n                realListener;\r\n\r\n            // 如果将listener的结构改成json\r\n            // 可以节省掉这个循环，优化性能\r\n            // 但是由于un的使用频率并不高，同时在listener不多的时候\r\n            // 遍历数组的性能消耗不会对代码产生影响\r\n            // 暂不考虑此优化\r\n            while (len--) {\r\n                item = lis[len];\r\n\r\n                // listener存在时，移除element的所有以listener监听的type类型事件\r\n                // listener不存在时，移除element的所有type类型事件\r\n                if (item[1] === type\r\n                    && item[0] === element\r\n                    && (isRemoveAll || item[2] === listener)) {\r\n                    realType = item[4];\r\n                    realListener = item[3];\r\n                    if (element.removeEventListener) {\r\n                        element.removeEventListener(realType, realListener, false);\r\n                    } else if (element.detachEvent) {\r\n                        element.detachEvent('on' + realType, realListener);\r\n                    }\r\n                    lis.splice(len, 1);\r\n                }\r\n            }\r\n            return element;\r\n        };\r\n\r\n        /**\r\n         * 获取event事件,解决不同浏览器兼容问题\r\n         * @param {Event}\r\n         * @return {Event}\r\n         */\r\n        baidu.getEvent = baidu.event.getEvent = function (event) {\r\n            return window.event || event;\r\n        };\r\n\r\n        /**\r\n         * 获取event.target,解决不同浏览器兼容问题\r\n         * @param {Event}\r\n         * @return {Target}\r\n         */\r\n        baidu.getTarget = baidu.event.getTarget = function (event) {\r\n            var event = baidu.getEvent(event);\r\n            return event.target || event.srcElement;\r\n        };\r\n\r\n        /**\r\n         * 阻止事件的默认行为\r\n         * @name baidu.event.preventDefault\r\n         * @function\r\n         * @grammar baidu.event.preventDefault(event)\r\n         * @param {Event} event 事件对象\r\n         * @meta standard\r\n         */\r\n        baidu.preventDefault = baidu.event.preventDefault = function (event) {\r\n            var event = baidu.getEvent(event);\r\n            if (event.preventDefault) {\r\n                event.preventDefault();\r\n            } else {\r\n                event.returnValue = false;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * 停止事件冒泡传播\r\n         * @param {Event}\r\n         */\r\n        baidu.stopBubble = baidu.event.stopBubble = function (event) {\r\n            event = baidu.getEvent(event);\r\n            event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;\r\n        };\r\n\r\n        /**\r\n         * 判断是否为ie浏览器\r\n         * @property ie ie版本号\r\n         * @grammar baidu.browser.ie\r\n         * @meta standard\r\n         * @shortcut ie\r\n         * @see baidu.browser.firefox,baidu.browser.safari,baidu.browser.opera,baidu.browser.chrome,baidu.browser.maxthon \r\n         */\r\n        baidu.browser = baidu.browser || {};\r\n        if (/msie (\\d+\\.\\d)/i.test(navigator.userAgent)) {\r\n            //IE 8下，以documentMode为准\r\n            //在百度模板中，可能会有$，防止冲突，将$1 写成 \\x241\r\n            baidu.browser.ie = baidu.ie = document.documentMode || + RegExp['\\x241'];\r\n        }\r\n\r\n    })();\r\n\r\n    /**\r\n     * @exports DrawingManager as BMapGLLib.DrawingManager\r\n     */\r\n    var DrawingManager =\r\n\r\n        /**\r\n         * DrawingManager类的构造函数\r\n         * @class 鼠标绘制管理类，实现鼠标绘制管理的<b>入口</b>。\r\n         * 实例化该类后，即可调用该类提供的open\r\n         * 方法开启绘制模式状态。\r\n         * 也可加入工具栏进行选择操作。\r\n         *\r\n         * @constructor\r\n         * @param {Map} map Baidu map的实例对象\r\n         * @param {Json Object} opts 可选的输入参数，非必填项。可输入选项包括：<br />\r\n         * {\"<b>isOpen</b>\" : {Boolean} 是否开启绘制模式\r\n         * <br />\"<b>enableDrawingTool</b>\" : {Boolean} 是否添加绘制工具栏控件，默认不添加\r\n         * <br />\"<b>drawingToolOptions</b>\" : {Json Object} 可选的输入参数，非必填项。可输入选项包括\r\n         * <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"<b>anchor</b>\" : {ControlAnchor} 停靠位置、默认左上角\r\n         * <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"<b>offset</b>\" : {Size} 偏移值。\r\n         * <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"<b>scale</b>\" : {Number} 工具栏的缩放比例,默认为1\r\n         * <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"<b>drawingModes</b>\" : {DrawingType<Array>} 工具栏上可以选择出现的绘制模式,将需要显示的DrawingType以数组型形式传入，如[BMAP_DRAWING_MARKER, BMAP_DRAWING_CIRCLE] 将只显示画点和画圆的选项\r\n         * <br />\"<b>enableSorption</b>\" : {Boolean} 是否开启边界吸附功能\r\n         * <br />\"<b>sorptiondistance</b>\" : {Number} 边界吸附距离\r\n         * <br />\"<b>enableCalculate</b>\" : {Boolean} 绘制是否进行测距(画线时候)、测面(画圆、多边形、矩形)\r\n         * <br />\"<b>markerOptions</b>\" : {MarkerOptions} 所画的点的可选参数，参考api中的<a href=\"http://developer.baidu.com/map/reference/index.php?title=Class:%E6%80%BB%E7%B1%BB/%E8%A6%86%E7%9B%96%E7%89%A9%E7%B1%BB\">对应类</a>\r\n         * <br />\"<b>circleOptions</b>\" : {CircleOptions} 所画的圆的可选参数，参考api中的<a href=\"http://developer.baidu.com/map/reference/index.php?title=Class:%E6%80%BB%E7%B1%BB/%E8%A6%86%E7%9B%96%E7%89%A9%E7%B1%BB\">对应类</a>\r\n         * <br />\"<b>polylineOptions</b>\" : {PolylineOptions} 所画的线的可选参数，参考api中的<a href=\"http://developer.baidu.com/map/reference/index.php?title=Class:%E6%80%BB%E7%B1%BB/%E8%A6%86%E7%9B%96%E7%89%A9%E7%B1%BB\">对应类</a>\r\n         * <br />\"<b>polygonOptions</b>\" : {PolygonOptions} 所画的多边形的可选参数，参考api中的<a href=\"http://developer.baidu.com/map/reference/index.php?title=Class:%E6%80%BB%E7%B1%BB/%E8%A6%86%E7%9B%96%E7%89%A9%E7%B1%BB\">对应类</a>\r\n         * <br />\"<b>rectangleOptions</b>\" : {PolygonOptions} 所画的矩形的可选参数，参考api中的<a href=\"http://developer.baidu.com/map/reference/index.php?title=Class:%E6%80%BB%E7%B1%BB/%E8%A6%86%E7%9B%96%E7%89%A9%E7%B1%BB\">对应类</a>\r\n         *\r\n         * @example <b>参考示例：</b><br />\r\n         * var map = new BMap.Map(\"container\");<br />map.centerAndZoom(new BMap.Point(116.404, 39.915), 15);<br />\r\n         * var myDrawingManagerObject = new BMapGLLib.DrawingManager(map, {isOpen: true,\r\n         *     drawingType: BMAP_DRAWING_MARKER, enableDrawingTool: true,\r\n         *     enableCalculate: false,\r\n         *     drawingToolOptions: {\r\n         *         anchor: BMAP_ANCHOR_TOP_LEFT,\r\n         *         offset: new BMap.Size(5, 5),\r\n         *         drawingModes : [\r\n         *             BMAP_DRAWING_MARKER,\r\n         *             BMAP_DRAWING_CIRCLE,\r\n         *             BMAP_DRAWING_POLYLINE,\r\n         *             BMAP_DRAWING_POLYGON,\r\n         *             BMAP_DRAWING_RECTANGLE\r\n         *          ]\r\n         *     },\r\n         *     polylineOptions: {\r\n         *         strokeColor: \"#333\"\r\n         *     });\r\n         */\r\n        BMapGLLib.DrawingManager = function (map, opts) {\r\n            if (!map) {\r\n                return;\r\n            }\r\n\r\n            instances.push(this);\r\n\r\n            opts = opts || {};\r\n            this.overlays = []; // 用来存储覆盖物\r\n\r\n            this._initialize(map, opts);\r\n        };\r\n\r\n    // 通过baidu.lang下的inherits方法，让DrawingManager继承baidu.lang.Class\r\n    baidu.lang.inherits(DrawingManager, baidu.lang.Class, 'DrawingManager');\r\n\r\n    /**\r\n     * 开启地图的绘制模式\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * myDrawingManagerObject.open();\r\n     */\r\n    DrawingManager.prototype.open = function () {\r\n        // 判断绘制状态是否已经开启\r\n        if (this._isOpen == true) {\r\n            return true;\r\n        }\r\n\r\n        closeInstanceExcept(this);\r\n\r\n        this._open();\r\n    };\r\n\r\n    /**\r\n     * 关闭地图的绘制状态\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * myDrawingManagerObject.close();\r\n     */\r\n    DrawingManager.prototype.close = function () {\r\n\r\n        // 判断绘制状态是否已经开启\r\n        if (this._isOpen == false) {\r\n            return true;\r\n        }\r\n\r\n        var me = this;\r\n        this._close();\r\n        me._map.removeOverlay(tip_label);\r\n        setTimeout(function () {\r\n            me._map.enableDoubleClickZoom();\r\n        }, 2000);\r\n\r\n    };\r\n\r\n    /**\r\n     * 设置当前的绘制模式，参数DrawingType，为5个可选常量:\r\n     * <br/>BMAP_DRAWING_MARKER    画点\r\n     * <br/>BMAP_DRAWING_CIRCLE    画圆\r\n     * <br/>BMAP_DRAWING_POLYLINE  画线\r\n     * <br/>BMAP_DRAWING_POLYGON   画多边形\r\n     * <br/>BMAP_DRAWING_RECTANGLE 画矩形\r\n     * @param {DrawingType} DrawingType\r\n     * @return {Boolean}\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * myDrawingManagerObject.setDrawingMode(BMAP_DRAWING_POLYLINE);\r\n     */\r\n    DrawingManager.prototype.setDrawingMode = function (drawingType) {\r\n        // 与当前模式不一样时候才进行重新绑定事件\r\n        if (this._drawingType != drawingType) {\r\n            closeInstanceExcept(this);\r\n            this._setDrawingMode(drawingType);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 获取当前的绘制模式\r\n     * @return {DrawingType} 绘制的模式\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * alert(myDrawingManagerObject.getDrawingMode());\r\n     */\r\n    DrawingManager.prototype.getDrawingMode = function () {\r\n        return this._drawingType;\r\n    };\r\n\r\n    /**\r\n     * 打开距离或面积计算\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * myDrawingManagerObject.enableCalculate();\r\n     */\r\n    DrawingManager.prototype.enableCalculate = function () {\r\n        this._enableCalculate = true;\r\n        this._addGeoUtilsLibrary();  // 异步调用GeoUtils\r\n    };\r\n\r\n    /**\r\n     * 关闭距离或面积计算\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * myDrawingManagerObject.disableCalculate();\r\n     */\r\n    DrawingManager.prototype.disableCalculate = function () {\r\n        this._enableCalculate = false;\r\n    };\r\n\r\n    /**\r\n     * 打开吸附功能\r\n     */\r\n    DrawingManager.prototype.enableSorption = function () {\r\n        this._enableSorption = true;\r\n    };\r\n\r\n    /**\r\n     * 关闭吸附功能\r\n     */\r\n    DrawingManager.prototype.disableSorption = function () {\r\n        this._enableSorption = false;\r\n    };\r\n\r\n\r\n    /**\r\n     * 打开gpc功能\r\n     */\r\n    DrawingManager.prototype.enableGpc = function () {\r\n        this._enableGpc = true;\r\n        this._addGPCLibrary();  // 异步调用gpc\r\n    };\r\n\r\n    /**\r\n     * 关闭gpc功能\r\n     */\r\n    DrawingManager.prototype.disableGpc = function () {\r\n        this._enableGpc = false;\r\n    };\r\n\r\n    /** \r\n     * 获取所有绘制的覆盖物\r\n     */\r\n    DrawingManager.prototype.getOverlays = function () {\r\n        return this.overlays;\r\n    };\r\n\r\n    DrawingManager.prototype.addOverlayData = function (overlay) {\r\n        return this.overlays.push(overlay);\r\n    };\r\n\r\n    DrawingManager.prototype.setOverlaysData = function (overlays) {\r\n        return this.overlays = overlays;\r\n    };\r\n\r\n    /**\r\n     * 清除指定覆盖物数据\r\n     */\r\n    DrawingManager.prototype.clearOverlayData = function (overlay) {\r\n        var map = this._map;\r\n        for (var i = 0; i < this.overlays.length; i++) {\r\n            if (this.overlays[i] === overlay) {\r\n                this.overlays.splice(i, 1);\r\n                return overlay;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 清除指定覆盖物\r\n     */\r\n    DrawingManager.prototype.clearOverlay = function (overlay) {\r\n        var map = this._map;\r\n        var overlay = this.clearOverlayData(overlay);\r\n        if (overlay) {\r\n            map.removeOverlay(overlay);\r\n        }\r\n    };\r\n\r\n    /** \r\n     * 清除所有绘制的覆盖物\r\n     */\r\n    DrawingManager.prototype.clearOverlays = function () {\r\n        var map = this._map;\r\n        this.overlays.forEach(function (overlay) {\r\n            map.removeOverlay(overlay);\r\n        });\r\n        this.overlays.length = 0;\r\n    };\r\n\r\n    /**\r\n     * 鼠标绘制完成后，派发总事件的接口\r\n     * @name DrawingManager#overlaycomplete\r\n     * @event\r\n     * @param {Event Object} e 回调函数会返回event参数，包括以下返回值：\r\n     * <br />{\"<b>drawingMode</b> : {DrawingType} 当前的绘制模式\r\n     * <br />\"<b>overlay</b>：{Marker||Polyline||Polygon||Circle} 对应的绘制模式返回对应的覆盖物\r\n     * <br />\"<b>calculate</b>：{Number} 需要开启计算模式才会返回这个值，当绘制线的时候返回距离、绘制多边形、圆、矩形时候返回面积，单位为米，\r\n     * <br />\"<b>label</b>：{Label} 计算面积时候出现在Map上的Label对象\r\n     *\r\n     * @example <b>参考示例：</b>\r\n     * myDrawingManagerObject.addEventListener(\"overlaycomplete\", function(e) {\r\n     *     alert(e.drawingMode);\r\n     *     alert(e.overlay);\r\n     *     alert(e.calculate);\r\n     *     alert(e.label);\r\n     * });\r\n     */\r\n\r\n    /**\r\n     * 绘制点完成后，派发的事件接口\r\n     * @name DrawingManager#markercomplete\r\n     * @event\r\n     * @param {Marker} overlay 回调函数会返回相应的覆盖物，\r\n     * <br />{\"<b>overlay</b> : {Marker}\r\n     *\r\n     * @example <b>参考示例：</b>\r\n     * myDrawingManagerObject.addEventListener(\"circlecomplete\", function(e, overlay) {\r\n     *     alert(overlay);\r\n     * });\r\n     */\r\n\r\n    /**\r\n     * 绘制圆完成后，派发的事件接口\r\n     * @name DrawingManager#circlecomplete\r\n     * @event\r\n     * @param {Circle} overlay 回调函数会返回相应的覆盖物，\r\n     * <br />{\"<b>overlay</b> : {Circle}\r\n     */\r\n\r\n    /**\r\n     * 绘制线完成后，派发的事件接口\r\n     * @name DrawingManager#polylinecomplete\r\n     * @event\r\n     * @param {Polyline} overlay 回调函数会返回相应的覆盖物，\r\n     * <br />{\"<b>overlay</b> : {Polyline}\r\n     */\r\n\r\n    /**\r\n     * 绘制多边形完成后，派发的事件接口\r\n     * @name DrawingManager#polygoncomplete\r\n     * @event\r\n     * @param {Polygon} overlay 回调函数会返回相应的覆盖物，\r\n     * <br />{\"<b>overlay</b> : {Polygon}\r\n     */\r\n\r\n    /**\r\n     * 绘制矩形完成后，派发的事件接口\r\n     * @name DrawingManager#rectanglecomplete\r\n     * @event\r\n     * @param {Polygon} overlay 回调函数会返回相应的覆盖物，\r\n     * <br />{\"<b>overlay</b> : {Polygon}\r\n     */\r\n\r\n    /**\r\n     * 初始化状态\r\n     * @param {Map} 地图实例\r\n     * @param {Object} 参数\r\n     */\r\n    DrawingManager.prototype._initialize = function (map, opts) {\r\n\r\n        /**\r\n         * map对象\r\n         * @private\r\n         * @type {Map}\r\n         */\r\n        this._map = map;\r\n\r\n        /**\r\n         * 配置对象\r\n         * @private\r\n         * @type {Object}\r\n         */\r\n        this._opts = opts;\r\n\r\n        /**\r\n         * 当前的绘制模式, 默认是绘制点\r\n         * @private\r\n         * @type {DrawingType}\r\n         */\r\n        this._drawingType = opts.drawingMode || BMAP_DRAWING_MARKER;\r\n\r\n        /**\r\n         * 是否添加添加鼠标绘制工具栏面板\r\n         */\r\n        if (opts.enableDrawingTool) {\r\n            this.enableDrawingTool();\r\n        }\r\n\r\n        if (opts.sorptionDistance !== undefined) {\r\n            this.setSorptionDistance(opts.sorptionDistance);\r\n        }\r\n\r\n        // 是否计算绘制出的面积\r\n        if (opts.enableCalculate === true) {\r\n            this.enableCalculate();\r\n        } else {\r\n            this.disableCalculate();\r\n        }\r\n\r\n        // 是否开启超限提示\r\n        if (opts.enableLimit === true) {\r\n            var limit = opts.limitOptions;\r\n            this.limit = limit;\r\n        }\r\n\r\n        // 是否开启吸附功能\r\n        if (opts.enableSorption === true) {\r\n            this.enableSorption();\r\n        } else {\r\n            this.disableSorption();\r\n        }\r\n\r\n        // 是否开启gpc功能\r\n        if (opts.enableGpc === true) {\r\n            this.enableGpc();\r\n        } else {\r\n            this.disableGpc();\r\n        }\r\n\r\n        /**\r\n         * 是否已经开启了绘制状态\r\n         * @private\r\n         * @type {Boolean}\r\n         */\r\n        this._isOpen = !!(opts.isOpen === true);\r\n        if (this._isOpen) {\r\n            this._open();\r\n        }\r\n\r\n        this.setPolygonOptions(opts.polygonOptions);\r\n        this.setMarkerOptions(opts.markerOptions);\r\n        this.setCircleOptions(opts.circleOptions);\r\n        this.setPolylineOptions(opts.polylineOptions);\r\n        this.setRectangleOptions(opts.rectangleOptions);\r\n        this.setLabelOptions(opts.labelOptions);\r\n        this.controlButton = opts.controlButton == 'right' ? 'right' : 'left';\r\n\r\n    };\r\n\r\n    DrawingManager.prototype.enableDrawingTool = function () {\r\n        var opts = this._opts;\r\n        if (!this._drawingTool) {\r\n            var drawingTool = new DrawingTool(this, opts.drawingToolOptions);\r\n            this._drawingTool = drawingTool;\r\n        }\r\n        this._map.addControl(this._drawingTool);\r\n    };\r\n\r\n    DrawingManager.prototype.disableDrawingTool = function () {\r\n        if (this._drawingTool) {\r\n            this._map.removeControl(this._drawingTool);\r\n        }\r\n    };\r\n\r\n    DrawingManager.prototype.setSorptionDistance = function (distance) {\r\n        this._sorptionDistance = distance || 0;\r\n    };\r\n\r\n    DrawingManager.prototype.setPolygonOptions = function (options) {\r\n        this.polygonOptions = options || {};\r\n    };\r\n\r\n    DrawingManager.prototype.setMarkerOptions = function (options) {\r\n        this.markerOptions = options || {};\r\n    };\r\n\r\n    DrawingManager.prototype.setCircleOptions = function (options) {\r\n        this.circleOptions = options || {};\r\n    };\r\n\r\n    DrawingManager.prototype.setPolylineOptions = function (options) {\r\n        this.polylineOptions = options || {};\r\n    };\r\n\r\n    DrawingManager.prototype.setRectangleOptions = function (options) {\r\n        this.rectangleOptions = options || {};\r\n    };\r\n\r\n    DrawingManager.prototype.setLabelOptions = function (options) {\r\n        this.labelOptions = options || {};\r\n    };\r\n\r\n    /**\r\n     * 开启地图的绘制状态\r\n     * @return {Boolean}，开启绘制状态成功，返回true；否则返回false。\r\n     */\r\n    DrawingManager.prototype._open = function () {\r\n\r\n        this._isOpen = true;\r\n\r\n        // 添加遮罩，所有鼠标操作都在这个遮罩上完成\r\n        if (!this._mask) {\r\n            this._mask = new Mask();\r\n            // debugger\r\n        }\r\n\r\n        this._map.addOverlay(this._mask);\r\n        this._setDrawingMode(this._drawingType);\r\n\r\n    };\r\n\r\n    /**\r\n     * 设置当前的绘制模式\r\n     * @param {DrawingType}\r\n     */\r\n    DrawingManager.prototype._setDrawingMode = function (drawingType) {\r\n\r\n        this._drawingType = drawingType;\r\n\r\n        /**\r\n         * 开启编辑状态时候才重新进行事件绑定\r\n         */\r\n        if (this._isOpen) {\r\n\r\n            // 清空之前的自定义事件\r\n            this._mask.__listeners = {};\r\n\r\n            switch (drawingType) {\r\n                case BMAP_DRAWING_MARKER:\r\n                    this._bindMarker();\r\n                    break;\r\n                case BMAP_DRAWING_CIRCLE:\r\n                    this._bindCircle();\r\n                    break;\r\n                case BMAP_DRAWING_POLYLINE:\r\n                case BMAP_DRAWING_POLYGON:\r\n                    this._bindPolylineOrPolygon();\r\n                    break;\r\n                case BMAP_DRAWING_RECTANGLE:\r\n                    this._bindRectangle();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 如果添加了工具栏，则也需要改变工具栏的样式\r\n         */\r\n        if (this._drawingTool && this._isOpen) {\r\n            this._drawingTool.setStyleByDrawingMode(drawingType);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 关闭地图的绘制状态\r\n     * @return {Boolean}，关闭绘制状态成功，返回true；否则返回false。\r\n     */\r\n    DrawingManager.prototype._close = function () {\r\n\r\n        this._isOpen = false;\r\n\r\n        if (this._mask) {\r\n            this._map.removeOverlay(this._mask);\r\n        }\r\n\r\n        /**\r\n         * 如果添加了工具栏，则关闭时候将工具栏样式设置为拖拽地图\r\n         */\r\n        if (this._drawingTool) {\r\n            this._drawingTool.setStyleByDrawingMode('hander');\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 绑定鼠标画点的事件\r\n     */\r\n    DrawingManager.prototype._bindMarker = function () {\r\n\r\n        var me = this,\r\n            map = this._map,\r\n            mask = this._mask;\r\n\r\n        /**\r\n         * 鼠标点击的事件\r\n         */\r\n        var clickAction = function (e) {\r\n            // 往地图上添加marker\r\n            var marker = new BMap.Marker(e.point, me.markerOptions);\r\n            map.addOverlay(marker);\r\n            me._dispatchOverlayComplete(marker);\r\n        };\r\n\r\n        mask.addEventListener('click', clickAction);\r\n    };\r\n\r\n    /**\r\n     * 绑定鼠标画圆的事件\r\n     */\r\n    var tip_label = null;\r\n    DrawingManager.prototype._bindCircle = function () {\r\n\r\n        var me = this,\r\n            map = this._map,\r\n            mask = this._mask,\r\n            circle = null,\r\n            overlays = [],\r\n            centerPoint = null; // 圆的中心点\r\n\r\n        var radius = 1;\r\n        var moveMarker = null;\r\n        var polyline = null;\r\n        var radiusWindow = null;\r\n        var operateWindow = null;\r\n\r\n        var lineStyel = {\r\n            strokeColor: '#4E6DF1', // 边线颜色。\r\n            strokeWeight: 2 // 边线的宽度，以像素为单位。\r\n        };\r\n\r\n        var centerIcon = new BMap.Icon(circlePng, new BMap.Size(20, 20));\r\n        var moveIcon = new BMap.Icon(nbPng, new BMap.Size(40, 20), {\r\n            imageOffset: new BMap.Size(0, 10)\r\n        });\r\n\r\n        /**\r\n         * 开始绘制圆形\r\n         */\r\n\r\n        var startAction = function (e) {\r\n            if (me.controlButton == 'right' && (e.button == 1 || e.button == 0)) {\r\n                return;\r\n            }\r\n\r\n            centerPoint = e.point;\r\n\r\n            var centerMarker = new BMap.Marker(centerPoint);\r\n            centerIcon.setImageSize(new BMap.Size(20, 20));\r\n            centerMarker.setIcon(centerIcon);\r\n            centerMarker.enableDragging();\r\n            centerMarker.addEventListener('dragstart', centerDragstart);\r\n            centerMarker.addEventListener('dragging', centerDragging);\r\n            centerMarker.addEventListener('dragend', centerDragend);\r\n            map.addOverlay(centerMarker);\r\n\r\n            overlays.push(centerMarker);\r\n\r\n            circle = new BMap.Circle(centerPoint, radius, me.circleOptions);\r\n            map.addOverlay(circle);\r\n            mask.enableEdgeMove();\r\n            mask.addEventListener('mousemove', moveAction);\r\n            baidu.on(document, 'mouseup', endAction);\r\n        };\r\n\r\n        /**\r\n         * 绘制圆形过程中，鼠标移动过程的事件\r\n         */\r\n        var moveAction = function (e) {\r\n            radius = me._map.getDistance(centerPoint, e.point).toFixed(0);\r\n            circle.setRadius(radius);\r\n\r\n            map.removeOverlay(tip_label);\r\n\r\n            tip_label = new BMap.Label('半径：' + radius + '米<br>松开完成绘制', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n        };\r\n\r\n        /**\r\n         * 绘制圆形结束\r\n         */\r\n        var endAction = function (e) {\r\n            var cz = map.getViewport(circle.getBounds());\r\n            cz.zoom -= 1;\r\n            map.setViewport(cz);\r\n            map.removeOverlay(tip_label);\r\n\r\n            var endPoint = new BMap.Point(circle.getBounds().getNorthEast().lng, centerPoint.lat);\r\n            mask.hide();\r\n\r\n            moveMarker = new BMap.Marker(endPoint);\r\n            moveMarker.setIcon(moveIcon);\r\n            moveMarker.enableDragging();\r\n            polyline = new BMap.Polyline([centerPoint, endPoint], lineStyel);\r\n\r\n            var midPoint = new BMap.Point((circle.getBounds().getNorthEast().lng + centerPoint.lng) / 2, centerPoint.lat);\r\n            radiusWindow = new Screenshot('circle', midPoint, radius, circle, me);\r\n\r\n            overlays = overlays.concat([moveMarker, polyline, radiusWindow]);\r\n            var limit = null;\r\n            if (me.limit) {\r\n                limit = me.limit.area;\r\n            }\r\n\r\n            var targetOverlay = {\r\n                limit: limit,\r\n                type: 'circle',\r\n                point: endPoint,\r\n                overlay: circle,\r\n                overlays: overlays\r\n            };\r\n            operateWindow = new Operate(targetOverlay, me);\r\n\r\n            map.addOverlay(moveMarker);\r\n            map.addOverlay(polyline);\r\n            map.addOverlay(radiusWindow);\r\n            map.addOverlay(operateWindow);\r\n\r\n            radiusWindow.addEventListener('radiuschange', function (e) {\r\n                var radius = e.radius;\r\n                circle.setRadius(radius);\r\n                var ePoint = getPointByDistance(centerPoint, radius, 'east');\r\n                var dragLeftPoint = new BMap.Point(ePoint.lng, centerPoint.lat);\r\n                var halflng = ePoint.lng > centerPoint.lng ? (circle.getBounds().getNorthEast().lng + centerPoint.lng) / 2 : (circle.getBounds().getSouthWest().lng + centerPoint.lng) / 2;\r\n                var halfLeftPoint = new BMap.Point(halflng, centerPoint.lat);\r\n                moveMarker.setPosition(dragLeftPoint);\r\n                radiusWindow.setInfo(halfLeftPoint, radius);\r\n                operateWindow.setPosition(dragLeftPoint, true);\r\n                operateWindow.updateWindow();\r\n                polyline.setPath([centerPoint, dragLeftPoint]);\r\n            });\r\n\r\n            moveMarker.addEventListener('dragging', function (e) {\r\n                var dragLeftPoint = new BMap.Point(e.latLng.lng, centerPoint.lat);\r\n                var halflng = e.latLng.lng > centerPoint.lng ? (circle.getBounds().getNorthEast().lng + centerPoint.lng) / 2 : (circle.getBounds().getSouthWest().lng + centerPoint.lng) / 2;\r\n                var isright = e.latLng.lng > centerPoint.lng ? true : false;\r\n                var halfLeftPoint = new BMap.Point(halflng, centerPoint.lat);\r\n\r\n                e.target.setPosition(dragLeftPoint);\r\n                radiusWindow.setInfo(halfLeftPoint, me._map.getDistance(centerPoint, e.latLng).toFixed(0));\r\n                operateWindow.setPosition(dragLeftPoint, isright);\r\n                polyline.setPath([centerPoint, dragLeftPoint]);\r\n                radius = me._map.getDistance(centerPoint, e.latLng).toFixed(0);\r\n                circle.setRadius(me._map.getDistance(centerPoint, e.latLng));\r\n            });\r\n\r\n            moveMarker.addEventListener('dragend', function (e) {\r\n                operateWindow.updateWindow();\r\n            });\r\n\r\n            mask.disableEdgeMove();\r\n            mask.removeEventListener('mousemove', moveAction);\r\n            mask.removeEventListener('mousemove', mousedownAction);\r\n            baidu.un(document, 'mouseup', endAction);\r\n            // me.close();\r\n            map.removeOverlay(mask);\r\n        };\r\n\r\n        /**\r\n         * 鼠标点击起始点\r\n         */\r\n        var mousedownAction = function (e) {\r\n            baidu.preventDefault(e);\r\n            baidu.stopBubble(e);\r\n\r\n            if (me.controlButton == 'right' && e.button == 1) {\r\n                return;\r\n            }\r\n\r\n            if (centerPoint == null) {\r\n                startAction(e);\r\n            }\r\n\r\n        };\r\n\r\n        /**\r\n         * 非绘制圆形过程中，鼠标移动过程的事件\r\n         */\r\n        var mousemoveAction = function (e) {\r\n            baidu.preventDefault(e);\r\n            baidu.stopBubble(e);\r\n\r\n            map.removeOverlay(tip_label);\r\n\r\n            tip_label = new BMap.Label('按下确认中心点，拖拽确认半径', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n\r\n        };\r\n\r\n        var centerDragstart = function (e) {\r\n            map.removeOverlay(moveMarker);\r\n            map.removeOverlay(polyline);\r\n            map.removeOverlay(radiusWindow);\r\n            map.removeOverlay(operateWindow);\r\n        };\r\n        var centerDragging = function (e) {\r\n            centerPoint = e.latLng;\r\n            circle.setCenter(e.latLng);\r\n        };\r\n        var centerDragend = function (e) {\r\n            centerPoint = e.latLng;\r\n            endAction(e);\r\n        };\r\n\r\n\r\n        mask.addEventListener('mousedown', mousedownAction);\r\n        mask.addEventListener('mousemove', mousemoveAction);\r\n    };\r\n\r\n    /**\r\n     * 画线和画多边形相似性比较大，公用一个方法\r\n     */\r\n    DrawingManager.prototype._bindPolylineOrPolygon = function () {\r\n\r\n        var me = this,\r\n            map = this._map,\r\n            mask = this._mask,\r\n            points = [], // 用户绘制的点\r\n            drawPoint = null, // 实际需要画在地图上的点\r\n            overlay = null,\r\n            match = null,\r\n            isBinded = false;\r\n        function getNorthEast() {\r\n            var bound = arguments[0];\r\n            var maxlng = 0;\r\n            var index = 0;\r\n            for (var j = 0; j < bound.length; j++) {\r\n                if (maxlng < bound[j].lng) {\r\n                    maxlng = bound[j].lng;\r\n                    index = j;\r\n                }\r\n            }\r\n            return bound[index];\r\n        }\r\n\r\n        /**\r\n         * 鼠标点击的事件\r\n         */\r\n        var startAction = function (e) {\r\n            if (me.controlButton === 'right' && (e.button === 1 || e.button === 0)) {\r\n                return;\r\n            }\r\n\r\n            var point = e.point;\r\n            if (match) {\r\n                point = match;\r\n            }\r\n            points.push(point);\r\n\r\n            drawPoint = points.concat(points[points.length - 1]);\r\n\r\n            if (points.length == 1) {\r\n                if (me._drawingType == BMAP_DRAWING_POLYLINE) {\r\n                    overlay = new BMap.Polyline(drawPoint, me.polylineOptions);\r\n                } else if (me._drawingType == BMAP_DRAWING_POLYGON) {\r\n                    overlay = new BMap.Polygon(drawPoint, me.polygonOptions);\r\n                }\r\n\r\n                map.addOverlay(overlay);\r\n            } else {\r\n                overlay.setPath(drawPoint);\r\n            }\r\n            if (!isBinded) {\r\n                isBinded = true;\r\n                mask.enableEdgeMove();\r\n                mask.removeEventListener('mousemove', mousemoveAction);\r\n                mask.addEventListener('mousemove', moveAction);\r\n                mask.addEventListener('dblclick', dblclickAction);\r\n            }\r\n\r\n        };\r\n\r\n        /**\r\n         * 鼠标移动过程的事件\r\n         */\r\n        var moveAction = function (e) {\r\n            var point = e.point;\r\n            if (me._enableSorption) {\r\n                var matchs = me.getSorptionMatch(point, me.overlays, me._sorptionDistance);\r\n                if (matchs && matchs.length > 0) {\r\n                    match = matchs[0].point;\r\n                    overlay.setPositionAt(drawPoint.length - 1, matchs[0].point);\r\n                    return;\r\n                }\r\n            }\r\n            match = null;\r\n\r\n            overlay.setPositionAt(drawPoint.length - 1, e.point);\r\n\r\n            map.removeOverlay(tip_label);\r\n\r\n            tip_label = new BMap.Label('单击绘制下一个点，双击完成绘制', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n        };\r\n\r\n        /**\r\n         * 鼠标双击的事件\r\n         */\r\n        var dblclickAction = function (e) {\r\n            baidu.stopBubble(e);\r\n            isBinded = false;\r\n            map.removeOverlay(tip_label);\r\n            mask.disableEdgeMove();\r\n            mask.removeEventListener('mousedown', startAction);\r\n            mask.removeEventListener('mousemove', moveAction);\r\n            mask.removeEventListener('mousemove', mousemoveAction);\r\n            mask.removeEventListener('dblclick', dblclickAction);\r\n\r\n            if (me.controlButton == 'right') {\r\n                points.push(e.point);\r\n            } else if (baidu.ie <= 8) {\r\n\r\n            } else {\r\n                points.pop();\r\n            }\r\n\r\n            // 裁剪\r\n            try {\r\n                if (me._enableGpc && window.gpcas && 'polygon' === me._drawingType) {\r\n                    var res = new gpcas.geometry.PolyDefault();\r\n                    for (var i = 0; i < points.length; i++) {\r\n                        res.addPoint(new gpcas.Point(points[i].lng, points[i].lat));\r\n                    }\r\n                    for (var j = 0; j < me.overlays.length; j++) {\r\n                        var path = me.overlays[j].getPath();\r\n                        var target = new gpcas.geometry.PolyDefault();\r\n                        for (var i = 0; i < path.length; i++) {\r\n                            target.addPoint(new gpcas.Point(path[i].lng, path[i].lat));\r\n                        }\r\n                        var diff = res.difference(target);\r\n                        var newPoints = diff.getPoints();\r\n                        var outPoints = [];\r\n                        for (var i = 0; i < newPoints.length; i++) {\r\n                            outPoints.push(new BMap.Point(newPoints[i].x, newPoints[i].y));\r\n                        }\r\n                        res = new gpcas.geometry.PolyDefault();\r\n                        for (var i = 0; i < newPoints.length; i++) {\r\n                            res.addPoint(new gpcas.Point(newPoints[i].x, newPoints[i].y));\r\n                        }\r\n                        points = outPoints;\r\n                    }\r\n                }\r\n            } catch (e) {\r\n            }\r\n\r\n            overlay.setPath(points);\r\n            var cz = map.getViewport(points);\r\n            cz.zoom -= 1;\r\n            map.setViewport(cz);\r\n\r\n            overlay.enableEditing();\r\n            var limit = null;\r\n            if (me.limit) {\r\n                limit = 'polygon' === me._drawingType ? me.limit.area : me.limit.distance;\r\n            }\r\n\r\n            var targetOverlay = {\r\n                limit: limit,\r\n                type: me._drawingType,\r\n                point: getNorthEast(points),\r\n                overlay: overlay,\r\n                overlays: []\r\n            };\r\n\r\n            var operateWindow = new Operate(targetOverlay, me);\r\n            map.addOverlay(operateWindow);\r\n\r\n            overlay.addEventListener('lineupdate', function (e) {\r\n                var point = getNorthEast(e.currentTarget.getPath());\r\n                operateWindow.setPosition(point, true);\r\n                operateWindow.updateWindow();\r\n            });\r\n\r\n            points.length = 0;\r\n            drawPoint.length = 0;\r\n            // me.close();\r\n            map.removeOverlay(mask);\r\n\r\n        };\r\n\r\n        /**\r\n         * 非绘制多边形过程中，鼠标移动过程的事件\r\n         */\r\n        var mousemoveAction = function (e) {\r\n            baidu.preventDefault(e);\r\n            baidu.stopBubble(e);\r\n\r\n            map.removeOverlay(tip_label);\r\n\r\n            tip_label = new BMap.Label('单击确认起点', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n        };\r\n\r\n        mask.addEventListener('mousemove', mousemoveAction);\r\n\r\n        // mask.addEventListener('mouseup', startAction);\r\n        mask.addEventListener('mousedown', startAction);\r\n\r\n        // 双击时候不放大地图级别\r\n        mask.addEventListener('dblclick', function (e) {\r\n\r\n            baidu.stopBubble(e);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * 绑定鼠标画矩形的事件\r\n     */\r\n\r\n    DrawingManager.prototype._bindRectangle = function () {\r\n\r\n        var me = this,\r\n            map = this._map,\r\n            mask = this._mask,\r\n            polygon = null,\r\n            startPoint = null;\r\n\r\n\r\n        // 获取4个顶点和4条边中点的坐标\r\n        function getRectAllPoints(pointA, pointB) {\r\n            var pointLT = new BMap.Point(pointA.lng, pointA.lat); // 左上角\r\n            var pointRT = new BMap.Point(pointB.lng, pointA.lat); // 右上角\r\n            var pointRB = new BMap.Point(pointB.lng, pointB.lat); // 右下角\r\n            var pointLB = new BMap.Point(pointA.lng, pointB.lat); // 左上角\r\n\r\n            var pointTC = new BMap.Point((pointA.lng + pointB.lng) / 2, pointA.lat);\r\n            var pointRC = new BMap.Point(pointB.lng, (pointA.lat + pointB.lat) / 2);\r\n            var pointBC = new BMap.Point((pointA.lng + pointB.lng) / 2, pointB.lat);\r\n            var pointLC = new BMap.Point(pointA.lng, (pointA.lat + pointB.lat) / 2);\r\n\r\n            return [pointLT, pointTC, pointRT, pointRC, pointRB, pointBC, pointLB, pointLC];\r\n        }\r\n\r\n        var moveIcon = new BMap.Icon(bulletPng, new BMap.Size(10, 10));\r\n        moveIcon.setImageSize(new BMap.Size(10, 10));\r\n\r\n        /**\r\n         * 开始绘制矩形\r\n         */\r\n        var startAction = function (e) {\r\n\r\n            baidu.stopBubble(e);\r\n            baidu.preventDefault(e);\r\n            if (me.controlButton == 'right' && (e.button == 1 || e.button == 0)) {\r\n                return;\r\n            }\r\n\r\n            startPoint = e.point;\r\n\r\n            var endPoint = startPoint;\r\n            polygon = new BMap.Polygon(me._getRectanglePoint(startPoint, endPoint), me.rectangleOptions);\r\n            map.addOverlay(polygon);\r\n            mask.enableEdgeMove();\r\n            mask.addEventListener('mousemove', moveAction);\r\n            baidu.on(document, 'mouseup', endAction);\r\n        };\r\n\r\n        /**\r\n         * 绘制矩形过程中，鼠标移动过程的事件\r\n         */\r\n        var moveAction = function (e) {\r\n            map.removeOverlay(tip_label);\r\n            polygon.setPath(me._getRectanglePoint(startPoint, e.point));\r\n\r\n            var points = getRectAllPoints(startPoint, e.point);\r\n            var width = me._map.getDistance(startPoint, points[2]).toFixed(0);\r\n            var height = me._map.getDistance(startPoint, points[6]).toFixed(0);\r\n            tip_label = new BMap.Label('尺寸：' + width + '米 x ' + height + '米<br>松开结束绘制', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n        };\r\n\r\n        /**\r\n         * 绘制矩形结束\r\n         */\r\n        var endAction = function (e) {\r\n            mask.hide();\r\n            var endPoint = null;\r\n            var markers = [];\r\n            var points = getRectAllPoints(startPoint, e.point);\r\n            var pointsTmp = [];\r\n            var cz = map.getViewport(points);\r\n            cz.zoom -= 1;\r\n            map.setViewport(cz);\r\n            map.removeOverlay(tip_label);\r\n\r\n            var width = me._map.getDistance(startPoint, points[2]).toFixed(0);\r\n            var height = me._map.getDistance(startPoint, points[6]).toFixed(0);\r\n            var rectInfo = new Screenshot('rectangle', points[0], {\r\n                width: width,\r\n                height: height\r\n            }, polygon, me);\r\n\r\n            for (var i = 0; i < points.length; i++) {\r\n                var marker = new BMap.Marker(points[i]);\r\n                marker.setIcon(moveIcon);\r\n                marker.enableDragging();\r\n                markers.push(marker);\r\n                map.addOverlay(marker);\r\n                pointsTmp[i] = me.mc2ll(marker.point);\r\n\r\n                marker.addEventListener('mousedown', function (e) {\r\n                    endPoint = me.mc2ll(e.target.point);\r\n                });\r\n                marker.addEventListener('dragging', function (e) {\r\n                    var point = e.latLng;\r\n                    for (var j = 0; j < pointsTmp.length; j++) {\r\n                        if (endPoint.lng == pointsTmp[j].lng) {\r\n                            points[j].lng = point.lng;\r\n                        }\r\n\r\n                        if (endPoint.lat == pointsTmp[j].lat) {\r\n                            points[j].lat = point.lat;\r\n                        }\r\n\r\n                    }\r\n                    points = getRectAllPoints(points[0], points[4]);\r\n                    for (var j = 0; j < markers.length; j++) {\r\n                        markers[j].setPosition(points[j]);\r\n                    }\r\n                    width = me._map.getDistance(points[0], points[2]).toFixed(0);\r\n                    height = me._map.getDistance(points[0], points[6]).toFixed(0);\r\n                    rectInfo.setInfo(points[0], {\r\n                        width: width,\r\n                        height: height\r\n                    });\r\n                    operateWindow.setPosition(points[3], true);\r\n                    polygon.setPath(points);\r\n                });\r\n                marker.addEventListener('dragend', function (e) {\r\n                    for (var i = 0; i < markers.length; i++) {\r\n                        var marker = markers[i];\r\n                        pointsTmp[i] = me.mc2ll(marker.point);\r\n                    }\r\n                    operateWindow.updateWindow();\r\n                });\r\n            }\r\n\r\n            rectInfo.addEventListener('rectwhchange', function (e) {\r\n                var width = e.width;\r\n                var height = e.height;\r\n                var pointx = getPointByDistance(points[0], width, 'east');\r\n                var pointy = getPointByDistance(points[0], height, 'south');\r\n                points[4].lng = pointx.lng;\r\n                points[4].lat = pointy.lat;\r\n                points = getRectAllPoints(points[0], points[4]);\r\n                for (var j = 0; j < markers.length; j++) {\r\n                    markers[j].setPosition(points[j]);\r\n                }\r\n                rectInfo.setInfo(points[0], {\r\n                    width: width,\r\n                    height: height\r\n                });\r\n                operateWindow.setPosition(points[3], true);\r\n                polygon.setPath(points);\r\n                for (var i = 0; i < markers.length; i++) {\r\n                    var marker = markers[i];\r\n                    pointsTmp[i] = me.mc2ll(marker.point);\r\n                }\r\n                operateWindow.updateWindow();\r\n            });\r\n\r\n            var overlays = [markers, rectInfo];\r\n            var limit = null;\r\n            if (me.limit) {\r\n                limit = me.limit.area;\r\n            }\r\n\r\n            var overlay = {\r\n                limit: limit,\r\n                type: 'rectangle',\r\n                point: points[3],\r\n                overlay: polygon,\r\n                overlays: overlays\r\n            };\r\n\r\n            var operateWindow = new Operate(overlay, me);\r\n            map.addOverlay(operateWindow);\r\n            map.addOverlay(rectInfo);\r\n\r\n            mask.disableEdgeMove();\r\n            mask.removeEventListener('mousemove', moveAction);\r\n            mask.removeEventListener('mousemove', mousemoveAction);\r\n            baidu.un(document, 'mouseup', endAction);\r\n            // me.close();\r\n            map.removeOverlay(mask);\r\n        };\r\n\r\n        /**\r\n         * 非绘制矩形过程中，鼠标移动过程的事件\r\n         */\r\n        var mousemoveAction = function (e) {\r\n            baidu.preventDefault(e);\r\n            baidu.stopBubble(e);\r\n\r\n            map.removeOverlay(tip_label);\r\n\r\n            tip_label = new BMap.Label('按住确认起点，拖拽进行绘制', {\r\n                position: e.point, // 指定文本标注所在的地理位置\r\n                offset: new BMap.Size(10, 10) // 设置文本偏移量\r\n            });\r\n            tip_label.setStyle(me.labelOptions);\r\n            map.addOverlay(tip_label);\r\n        };\r\n\r\n        mask.addEventListener('mousedown', startAction);\r\n        mask.addEventListener('mousemove', mousemoveAction);\r\n    };\r\n\r\n    /**\r\n     * 添加显示所绘制图形的面积或者长度\r\n     * @param {overlay} 覆盖物\r\n     * @param {point} 显示的位置\r\n     */\r\n    DrawingManager.prototype._calculate = function (overlay, point) {\r\n        var result = {\r\n            data: 0, // 计算出来的长度或面积\r\n            label: null // 显示长度或面积的label对象\r\n        };\r\n\r\n        if (this._enableCalculate && BMapGLLib.GeoUtils) {\r\n            var type = overlay.toString();\r\n            // 不同覆盖物调用不同的计算方法\r\n            switch (type) {\r\n                case 'Polyline': //[object Polyline]==>在3D版本中已经转为了Polyline\r\n                    result.data = BMapGLLib.GeoUtils.getPolylineDistance(overlay);\r\n                    break;\r\n                case 'Polygon':\r\n                    result.data = BMapGLLib.GeoUtils.getPolygonArea(overlay);\r\n                    break;\r\n                case 'Circle':\r\n                    var radius = overlay.getRadius();\r\n                    result.data = Math.PI * radius * radius;\r\n                    break;\r\n            }\r\n            // 异常情况处理\r\n            if (!result.data || result.data < 0) {\r\n                result.data = 0;\r\n                // console.error('计算函数异常处理');\r\n            } else {\r\n                // 保留2位小数位\r\n                result.data = result.data.toFixed(2);\r\n            }\r\n\r\n            /**\r\n             * 这里我们只需要开启计算面积功能，但并不需要在地图上添加显示面积的label，所以注释掉\r\n             */\r\n            // result.label = this._addLabel(point, result.data);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * 开启测距和测面功能需要依赖于GeoUtils库\r\n     * 所以这里判断用户是否已经加载,若未加载则用js动态加载\r\n     */\r\n    DrawingManager.prototype._addGeoUtilsLibrary = function () {\r\n        if (!BMapGLLib.GeoUtils) {\r\n            var script = document.createElement('script');\r\n            script.setAttribute('type', 'text/javascript');\r\n            script.setAttribute('src', '//mapopen.cdn.bcebos.com/github/BMapGLLib/GeoUtils/src/GeoUtils.min.js');\r\n            // script.setAttribute('src', '../../GeoUtils/GeoUtils.js');\r\n            document.body.appendChild(script);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 开启裁剪功能需要依赖于gpc库\r\n     * 所以这里判断用户是否已经加载,若未加载则用js动态加载\r\n     */\r\n    DrawingManager.prototype._addGPCLibrary = function () {\r\n        if (!window.gpcas) {\r\n            var script = document.createElement('script');\r\n            script.setAttribute('type', 'text/javascript');\r\n            script.setAttribute('src', '//mapopen.cdn.bcebos.com/github/BMapGLLib/DrawingManager/src/gpc.js');\r\n            // script.setAttribute('src', '../src/gpc.js');\r\n            document.body.appendChild(script);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 向地图中添加文本标注\r\n     * @param {Point}\r\n     * @param {String} 所以显示的内容\r\n     */\r\n    DrawingManager.prototype._addLabel = function (point, content) {\r\n        var label = new BMap.Label(content, {\r\n            position: point\r\n        });\r\n        this._map.addOverlay(label);\r\n        return label;\r\n    };\r\n\r\n    /**\r\n     * 根据起终点获取矩形的四个顶点\r\n     * @param {Point} 起点\r\n     * @param {Point} 终点\r\n     */\r\n    DrawingManager.prototype._getRectanglePoint = function (startPoint, endPoint) {\r\n        return [\r\n            new BMap.Point(startPoint.lng, startPoint.lat),\r\n            new BMap.Point(endPoint.lng, startPoint.lat),\r\n            new BMap.Point(endPoint.lng, endPoint.lat),\r\n            new BMap.Point(startPoint.lng, endPoint.lat)\r\n        ];\r\n    };\r\n\r\n    /**\r\n     * 派发成功事件\r\n     */\r\n    DrawingManager.prototype._dispatchOverlayComplete = function (overlay, calculate) {\r\n        var options = {\r\n            overlay: overlay,\r\n            drawingMode: this._drawingType\r\n        };\r\n        if (calculate) {\r\n            options.calculate = calculate.data || null;\r\n            options.label = calculate.label || null;\r\n        }\r\n\r\n        this.dispatchEvent(this._drawingType + 'complete', overlay);\r\n        this.dispatchEvent('overlaycomplete', options);\r\n    };\r\n\r\n    /**\r\n     * 派发失败事件\r\n     */\r\n    DrawingManager.prototype._dispatchOverlayCancel = function (overlay) {\r\n        var options = {\r\n            overlay: overlay,\r\n            drawingMode: this._drawingType\r\n        };\r\n\r\n        this.dispatchEvent(this._drawingType + 'cancel', overlay);\r\n        this.dispatchEvent('overlaycancel', options);\r\n    };\r\n\r\n    // 判断吸附算法\r\n    DrawingManager.prototype.getSorptionMatch = function (point, polygons, distance) {\r\n        distance = distance || 20;\r\n        var map = this._map;\r\n        var P = map.pointToPixel(point); // point.pixel;\r\n        var match = [];\r\n        for (var j = 0; j < polygons.length; j++) {\r\n            var pixels = polygons[j].getPath();\r\n            var first = pixels[0];\r\n            var last = pixels[pixels.length - 1];\r\n            if (!first.equals(last)) {\r\n                pixels.push(pixels[0]);\r\n            }\r\n            for (var i = 1; i < pixels.length; i++) {\r\n                var A = map.pointToPixel(pixels[i - 1]);\r\n                var B = map.pointToPixel(pixels[i]);\r\n                var vAP = [P.x - A.x, P.y - A.y];\r\n                var vAB = [B.x - A.x, B.y - A.y];\r\n                var vPB = [B.x - P.x, B.y - P.y];\r\n                var cAPAB = vAP[0] * vAB[0] + vAP[1] * vAB[1];\r\n                var lAPAB = Math.sqrt(Math.pow(vAP[0], 2) + Math.pow(vAP[1], 2)) * Math.sqrt(Math.pow(vAB[0], 2) + Math.pow(vAB[1], 2));\r\n                var rPAB = Math.acos(cAPAB / lAPAB);\r\n                var cABPB = vAB[0] * vPB[0] + vAB[1] * vPB[1];\r\n                var lABPB = Math.sqrt(Math.pow(vAB[0], 2) + Math.pow(vAB[1], 2)) * Math.sqrt(Math.pow(vPB[0], 2) + Math.pow(vPB[1], 2));\r\n                var rPBA = Math.acos(cABPB / lABPB);\r\n                if (rPAB < Math.PI / 2 && rPBA < Math.PI / 2) {\r\n                    var lAP = Math.sqrt(Math.pow(vAP[0], 2) + Math.pow(vAP[1], 2));\r\n                    var lAB = Math.sqrt(Math.pow(vAB[0], 2) + Math.pow(vAB[1], 2));\r\n                    var lAO = Math.cos(rPAB) * lAP;\r\n                    var pAOAB = lAO / lAB;\r\n                    var lPO = Math.sin(rPAB) * lAP;\r\n                    var O = [A.x + vAB[0] * pAOAB, A.y + vAB[1] * pAOAB];\r\n                    if (lPO < distance) {\r\n                        match.push({\r\n                            point: map.pixelToPoint({\r\n                                x: O[0],\r\n                                y: O[1]\r\n                            }),\r\n                            length: lPO\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        match.sort(function (a, b) {\r\n            return a.length - b.length;\r\n        });\r\n        var ret = match.length > 0 ? match : null;\r\n        return ret;\r\n    }\r\n\r\n    // 墨卡托坐标转经纬度\r\n    DrawingManager.prototype.mc2ll = function (point) {\r\n        var map = this._map;\r\n        var ll = mercatorToLnglat(point.lng, point.lat);\r\n        console.log(ll)\r\n        return new BMap.Point(ll[0], ll[1]);\r\n    };\r\n\r\n    // 经纬度坐标转墨卡托\r\n    DrawingManager.prototype.ll2mc = function (point) {\r\n        var map = this._map;\r\n        var mc = lnglatToMercator(point.lng, point.lat);\r\n        console.log(mc)\r\n        return new BMap.Point(mc[0], mc[1]);\r\n    };\r\n    // lonlatToMercator\r\n    // 确认,取消操作覆盖物\r\n    function Operate(data, DrawingManager) {\r\n        this.limit = data.limit;\r\n        this.type = data.type;\r\n        this.point = data.point;\r\n        this.overlay = data.overlay;\r\n        this.overlays = data.overlays;\r\n        this.DrawingManager = DrawingManager;\r\n    }\r\n\r\n    Operate.prototype = new BMap.Overlay();\r\n    Operate.prototype.dispatchEvent = baidu.lang.Class.prototype.dispatchEvent;\r\n    Operate.prototype.addEventListener = baidu.lang.Class.prototype.addEventListener;\r\n    Operate.prototype.removeEventListener = baidu.lang.Class.prototype.removeEventListener;\r\n\r\n    Operate.prototype.initialize = function (map) {\r\n        var me = this;\r\n        this._map = map;\r\n        var overlyTypeText = (this.type === 'polyline' ? '长度' : '面积');\r\n        var unit = (this.type === 'polyline' ? '万米' : '万平方米');\r\n        var div = this.div = document.createElement('div');\r\n        div.className = 'operateWindow';\r\n        var html = '<div><span id=\"confirmOperate\"></span><span id=\"cancelOperate\"></span><span id=\"warnOperate\">' + overlyTypeText + '不超过' + this.limit / 10000 + unit + '！</span></div>';\r\n        div.innerHTML = html;\r\n        this._map.getPanes().markerPane.appendChild(div);\r\n        this.updateWindow();\r\n        this._bind();\r\n        return div;\r\n    };\r\n\r\n    Operate.prototype._bind = function () {\r\n        var that = this;\r\n        var map = this._map;\r\n        var overlay = this.overlay;\r\n        var overlays = this.overlays;\r\n        document.getElementById('confirmOperate').addEventListener('click', function (e) {\r\n            map.removeOverlay(that);\r\n\r\n            if (that.type == 'rectangle') {\r\n                var calculate = that.DrawingManager._calculate(overlay, overlay.getPath());\r\n                that.DrawingManager.overlays.push(overlay);\r\n            }\r\n            else if (that.type == 'circle') {\r\n                var calculate = that.DrawingManager._calculate(overlay, that.point);\r\n                that.DrawingManager.overlays.push(overlay);\r\n            }\r\n            else if (that.type == 'polygon') {\r\n                var calculate = that.DrawingManager._calculate(overlay, (overlay.getPath()));\r\n                that.DrawingManager.overlays.push(overlay);\r\n                overlay.disableEditing();\r\n            }\r\n            else if (that.type == 'polyline') {\r\n                var calculate = that.DrawingManager._calculate(overlay, (overlay.getPath()));\r\n                that.DrawingManager.overlays.push(overlay);\r\n                overlay.disableEditing();\r\n            }\r\n\r\n            that.DrawingManager._dispatchOverlayComplete(overlay, calculate);\r\n\r\n            for (var i = 0; i < overlays.length; i++) {\r\n                if (Array.isArray(overlays[i])) {\r\n                    for (var k in overlays[i]) {\r\n                        map.removeOverlay(overlays[i][k]);\r\n                    }\r\n                } else {\r\n                    map.removeOverlay(overlays[i]);\r\n                }\r\n            }\r\n            that.DrawingManager.close();\r\n        });\r\n        document.getElementById('cancelOperate').addEventListener('click', function (e) {\r\n            map.removeOverlay(that);\r\n            for (var i = 0; i < overlays.length; i++) {\r\n                if (Array.isArray(overlays[i])) {\r\n                    for (var k in overlays[i]) {\r\n                        map.removeOverlay(overlays[i][k]);\r\n                    }\r\n                } else {\r\n                    map.removeOverlay(overlays[i]);\r\n                }\r\n            }\r\n            map.removeOverlay(overlay);\r\n\r\n            that.DrawingManager._dispatchOverlayCancel(overlay);\r\n            // that.DrawingManager._mask.show();\r\n            // that.DrawingManager._setDrawingMode(that.type);\r\n            that.DrawingManager.close();\r\n        });\r\n    };\r\n\r\n    Operate.prototype.updateWindow = function () {\r\n        if (this.domElement === null) {\r\n            return;\r\n        }\r\n        var overlay = this.overlay;\r\n        var limit = this.limit;\r\n        var calculate;\r\n        if (this.type == 'rectangle') {\r\n            calculate = this.DrawingManager._calculate(overlay, overlay.getPath());\r\n        }\r\n        else if (this.type == 'circle') {\r\n            calculate = this.DrawingManager._calculate(overlay, this.point);\r\n        }\r\n        else if (this.type == 'polygon') {\r\n            calculate = this.DrawingManager._calculate(overlay, overlay.getPath());\r\n        }\r\n        else if (this.type == 'polyline') {\r\n            calculate = this.DrawingManager._calculate(overlay, overlay.getPath());\r\n        }\r\n\r\n        if (Object.prototype.toString.call(limit) === '[object Number]' && calculate.data > limit) {\r\n            document.getElementById('confirmOperate').style.display = 'none';\r\n            document.getElementById('warnOperate').style.display = 'block';\r\n        }\r\n        else {\r\n            document.getElementById('confirmOperate').style.display = 'block';\r\n            document.getElementById('warnOperate').style.display = 'none';\r\n        }\r\n    };\r\n\r\n    Operate.prototype.setPosition = function (point, isright) {\r\n        this.point = point;\r\n        var map = this._map,\r\n            pixel = map.pointToOverlayPixel(this.point);\r\n        if (isright) {\r\n            this.div.classList.remove('operateLeft');\r\n            this.div.style.left = pixel.x + 15 + 'px';\r\n        }\r\n        else {\r\n            this.div.classList.add('operateLeft');\r\n            this.div.style.left = pixel.x - 105 + 'px';\r\n        }\r\n        this.div.style.top = pixel.y - 16 + 'px';\r\n    };\r\n\r\n    Operate.prototype.draw = function () {\r\n        var map = this._map,\r\n            pixel = map.pointToOverlayPixel(this.point);\r\n        this.div.style.left = pixel.x + 15 + 'px';\r\n        this.div.style.top = pixel.y - 16 + 'px';\r\n    };\r\n\r\n    // 显示,编辑半径覆盖物\r\n    function Screenshot(type, point, number, overlay, DrawingManager) {\r\n        this.type = type;\r\n        this.point = point;\r\n        this.number = number;\r\n        this.overlay = overlay;\r\n        this.DrawingManager = DrawingManager;\r\n    }\r\n\r\n    Screenshot.prototype = new BMap.Overlay();\r\n\r\n    Screenshot.prototype.dispatchEvent = baidu.lang.Class.prototype.dispatchEvent;\r\n    Screenshot.prototype.addEventListener = baidu.lang.Class.prototype.addEventListener;\r\n    Screenshot.prototype.removeEventListener = baidu.lang.Class.prototype.removeEventListener;\r\n\r\n    Screenshot.prototype.initialize = function (map) {\r\n        var me = this;\r\n        this._map = map;\r\n        var div = this.div = document.createElement('div');\r\n        div.className = 'screenshot';\r\n        if (this.type == 'circle') {\r\n            var html = '<div class=\"circlShot\"><span id=\"screenshotNum\">' + this.number + '</span><input id=\"circleInput\" type=\"text\" /><span class=\"unit\">米</span></div>';\r\n        }\r\n        else if (this.type == 'rectangle') {\r\n            var html = '<div class=\"rectWH\"><div class=\"wh\"><span id=\"rectWidth\">' + this.number.width + '</span><input id=\"rectWidthInput\" type=\"text\" /></div><span class=\"multiple\">x</span><div class=\"wh\"><span id=\"rectHeight\">' + this.number.height + '</span><input id=\"rectHeightInput\" type=\"text\" /></div><span class=\"unit\">米</span></div>';\r\n        }\r\n\r\n        div.innerHTML = html;\r\n        this._map.getPanes().markerPane.appendChild(div);\r\n        this._bind();\r\n        return div;\r\n    };\r\n\r\n    Screenshot.prototype._bind = function () {\r\n        this.setNumber(this.number);\r\n\r\n        if (this.type == 'circle') {\r\n            this.bindCircleEvent();\r\n        } else {\r\n            this.bindRectEvent();\r\n        }\r\n    };\r\n\r\n    Screenshot.prototype.bindCircleEvent = function () {\r\n        var that = this;\r\n        var circleSpn = document.getElementById('screenshotNum');\r\n        var circleInput = document.getElementById('circleInput');\r\n        circleSpn.addEventListener('click', function (e) {\r\n            var val = circleSpn.innerText;\r\n            circleSpn.style.display = 'none';\r\n            circleInput.value = val;\r\n            circleInput.style.display = 'inline-block';\r\n            circleInput.focus();\r\n        });\r\n        circleInput.addEventListener('click', function (e) {\r\n            circleInput.focus();\r\n        });\r\n        circleInput.addEventListener('keydown', function (e) {\r\n            if (e.keyCode === 13) {\r\n                var val = circleInput.value;\r\n                circleInput.style.display = 'none';\r\n                circleSpn.style.display = 'inline-block';\r\n                circleSpn.innerText = val;\r\n                var opt = {\r\n                    radius: val,\r\n                    overlay: that.overlay\r\n                };\r\n                that._dispatchRadiusChange(opt);\r\n            }\r\n        });\r\n        circleInput.addEventListener('blur', function (e) {\r\n            var val = circleInput.value;\r\n            circleInput.style.display = 'none';\r\n            circleSpn.style.display = 'inline-block';\r\n            circleSpn.innerText = val;\r\n            var opt = {\r\n                radius: val,\r\n                overlay: that.overlay\r\n            };\r\n            that._dispatchRadiusChange(opt);\r\n        });\r\n    };\r\n\r\n    Screenshot.prototype.bindRectEvent = function () {\r\n        var that = this;\r\n        var rectWidthSpn = document.getElementById('rectWidth');\r\n        var rectWidthInput = document.getElementById('rectWidthInput');\r\n        var rectHeightSpn = document.getElementById('rectHeight');\r\n        var rectHeightInput = document.getElementById('rectHeightInput');\r\n        rectWidthInput.value = rectWidthSpn.innerText;\r\n        rectHeightInput.value = rectHeightSpn.innerText;\r\n        rectWidthSpn.addEventListener('click', function (e) {\r\n            var val = rectWidthSpn.innerText;\r\n            rectWidthSpn.style.display = 'none';\r\n            rectWidthInput.value = val;\r\n            rectWidthInput.style.display = 'inline-block';\r\n            rectWidthInput.focus();\r\n        });\r\n        rectHeightSpn.addEventListener('click', function (e) {\r\n            var val = rectHeightSpn.innerText;\r\n            rectHeightSpn.style.display = 'none';\r\n            rectHeightInput.value = val;\r\n            rectHeightInput.style.display = 'inline-block';\r\n            rectHeightInput.focus();\r\n        });\r\n        rectWidthInput.addEventListener('click', function (e) {\r\n            rectWidthInput.focus();\r\n        });\r\n        rectHeightInput.addEventListener('click', function (e) {\r\n            rectHeightInput.focus();\r\n        });\r\n        rectWidthInput.addEventListener('keydown', function (e) {\r\n            if (e.keyCode === 13) {\r\n                var widthVal = rectWidthInput.value;\r\n                var heightVal = rectHeightInput.value;\r\n                rectWidthInput.style.display = 'none';\r\n                rectHeightInput.style.display = 'none';\r\n                rectWidthSpn.style.display = 'inline-block';\r\n                rectHeightSpn.style.display = 'inline-block';\r\n                rectWidthSpn.innerText = widthVal;\r\n                rectHeightSpn.innerText = heightVal;\r\n                var opt = {\r\n                    width: widthVal,\r\n                    height: heightVal,\r\n                    overlay: that.overlay\r\n                };\r\n                that._dispatchRectWHChange(opt);\r\n            }\r\n        });\r\n        rectHeightInput.addEventListener('keydown', function (e) {\r\n            if (e.keyCode === 13) {\r\n                var widthVal = rectWidthInput.value;\r\n                var heightVal = rectHeightInput.value;\r\n                rectWidthInput.style.display = 'none';\r\n                rectHeightInput.style.display = 'none';\r\n                rectWidthSpn.style.display = 'inline-block';\r\n                rectHeightSpn.style.display = 'inline-block';\r\n                rectWidthSpn.innerText = widthVal;\r\n                rectHeightSpn.innerText = heightVal;\r\n                var opt = {\r\n                    width: widthVal,\r\n                    height: heightVal,\r\n                    overlay: that.overlay\r\n                };\r\n                that._dispatchRectWHChange(opt);\r\n            }\r\n        });\r\n    };\r\n\r\n    Screenshot.prototype.setInfo = function (point, number) {\r\n        this.setNumber(number);\r\n        this.setPosition(point);\r\n    };\r\n\r\n    Screenshot.prototype.setNumber = function (number) {\r\n        if (this.type == 'circle') {\r\n            document.getElementById('screenshotNum').textContent = number;\r\n        }\r\n        else {\r\n            document.getElementById('rectWidth').textContent = number.width;\r\n            document.getElementById('rectHeight').textContent = number.height;\r\n        }\r\n    };\r\n\r\n    Screenshot.prototype.setPosition = function (point) {\r\n        this.point = point;\r\n        var map = this._map,\r\n            type = this.type,\r\n            pixel = map.pointToOverlayPixel(this.point);\r\n        if (type == 'circle') {\r\n            this.div.style.left = pixel.x - 30 + 'px';\r\n            this.div.style.top = pixel.y - 40 + 'px';\r\n        }\r\n        else if (type == 'rectangle') {\r\n            this.div.style.left = pixel.x + 'px';\r\n            this.div.style.top = pixel.y - 45 + 'px';\r\n        }\r\n\r\n    };\r\n\r\n    Screenshot.prototype.draw = function () {\r\n        var map = this._map,\r\n            type = this.type,\r\n            pixel = map.pointToOverlayPixel(this.point);\r\n        if (type == 'circle') {\r\n            this.div.style.left = pixel.x - 30 + 'px';\r\n            this.div.style.top = pixel.y - 40 + 'px';\r\n        }\r\n        else if (type == 'rectangle') {\r\n            this.div.style.left = pixel.x + 'px';\r\n            this.div.style.top = pixel.y - 45 + 'px';\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 派发事件\r\n     */\r\n    Screenshot.prototype._dispatchRadiusChange = function (opt) {\r\n        this.dispatchEvent('radiuschange', opt);\r\n    };\r\n\r\n    /**\r\n     * 派发事件\r\n     */\r\n    Screenshot.prototype._dispatchRectWHChange = function (opt) {\r\n        this.dispatchEvent('rectwhchange', opt);\r\n    };\r\n\r\n    /**\r\n     * 创建遮罩对象\r\n     */\r\n    function Mask() {\r\n\r\n        /**\r\n         * 鼠标到地图边缘的时候是否自动平移地图\r\n         */\r\n        this._enableEdgeMove = false;\r\n    }\r\n\r\n    Mask.prototype = new BMap.Overlay();\r\n    \r\n    /**\r\n     * 这里不使用api中的自定义事件，是为了更灵活使用\r\n     */\r\n    Mask.prototype.dispatchEvent = baidu.lang.Class.prototype.dispatchEvent;\r\n    Mask.prototype.addEventListener = baidu.lang.Class.prototype.addEventListener;\r\n    Mask.prototype.removeEventListener = baidu.lang.Class.prototype.removeEventListener;\r\n\r\n    Mask.prototype.initialize = function (map) {\r\n        var me = this;\r\n        this._map = map;\r\n        var div = this.container = document.createElement('div');\r\n        var size = this._map.getSize();\r\n        div.style.cssText = 'position:absolute;background:transparent;cursor:crosshair;width:' + size.width + 'px;height:' + size.height + 'px';\r\n        this._map.addEventListener('resize', function (e) {\r\n            me._adjustSize(e.size);\r\n        });\r\n        this._map.getPanes().floatPane.appendChild(div);\r\n        this._bind();\r\n        return div;\r\n    };\r\n\r\n    Mask.prototype.draw = function () {\r\n        var map = this._map,\r\n            point = map.pixelToPoint(new BMap.Pixel(0, 0)),\r\n            pixel = map.pointToOverlayPixel(point);\r\n        this.container.style.left = pixel.x + 'px';\r\n        this.container.style.top = pixel.y + 'px';\r\n    };\r\n\r\n    /**\r\n     * 开启鼠标到地图边缘，自动平移地图\r\n     */\r\n    Mask.prototype.enableEdgeMove = function () {\r\n        this._enableEdgeMove = true;\r\n    };\r\n\r\n    /**\r\n     * 关闭鼠标到地图边缘，自动平移地图\r\n     */\r\n    Mask.prototype.disableEdgeMove = function () {\r\n        clearInterval(this._edgeMoveTimer);\r\n        this._enableEdgeMove = false;\r\n    };\r\n\r\n    /**\r\n     * 绑定事件,派发自定义事件\r\n     */\r\n    Mask.prototype._bind = function () {\r\n\r\n        var me = this,\r\n            map = this._map,\r\n            container = this.container,\r\n            lastMousedownXY = null,\r\n            lastClickXY = null;\r\n\r\n        /**\r\n         * 根据event对象获取鼠标的xy坐标对象\r\n         * @param {Event}\r\n         * @return {Object} {x:e.x, y:e.y}\r\n         */\r\n        var getXYbyEvent = function (e) {\r\n            return {\r\n                x: e.clientX,\r\n                y: e.clientY\r\n            };\r\n        };\r\n\r\n        var domEvent = function (e) {\r\n            var type = e.type;\r\n            e = baidu.getEvent(e);\r\n            point = me.getDrawPoint(e); // 当前鼠标所在点的地理坐标\r\n\r\n            var dispatchEvent = function (type) {\r\n                e.point = point;\r\n                me.dispatchEvent(e);\r\n            };\r\n\r\n            if (type == 'mousedown') {\r\n                lastMousedownXY = getXYbyEvent(e);\r\n            }\r\n\r\n            var nowXY = getXYbyEvent(e);\r\n            // click经过一些特殊处理派发，其他同事件按正常的dom事件派发\r\n            if (type == 'click') {\r\n                // 鼠标点击过程不进行移动才派发click和dblclick\r\n                if (Math.abs(nowXY.x - lastMousedownXY.x) < 5 && Math.abs(nowXY.y - lastMousedownXY.y) < 5) {\r\n                    if (!lastClickXY || !(Math.abs(nowXY.x - lastClickXY.x) < 5 && Math.abs(nowXY.y - lastClickXY.y) < 5)) {\r\n                        dispatchEvent('click');\r\n                        lastClickXY = getXYbyEvent(e);\r\n                    } else {\r\n                        lastClickXY = null;\r\n                    }\r\n                }\r\n            } else {\r\n                dispatchEvent(type);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * 将事件都遮罩层的事件都绑定到domEvent来处理\r\n         */\r\n        var events = ['click', 'mousedown', 'mousemove', 'mouseup', 'dblclick'],\r\n            index = events.length;\r\n        while (index--) {\r\n            baidu.on(container, events[index], domEvent);\r\n        }\r\n\r\n        // 鼠标移动过程中，到地图边缘后自动平移地图\r\n        baidu.on(container, 'mousemove', function (e) {\r\n            if (me._enableEdgeMove) {\r\n                me.mousemoveAction(e);\r\n            }\r\n\r\n        });\r\n    };\r\n\r\n    // 鼠标移动过程中，到地图边缘后自动平移地图\r\n    Mask.prototype.mousemoveAction = function (e) {\r\n        function getClientPosition(e) {\r\n            var clientX = e.clientX,\r\n                clientY = e.clientY;\r\n            if (e.changedTouches) {\r\n                clientX = e.changedTouches[0].clientX;\r\n                clientY = e.changedTouches[0].clientY;\r\n            }\r\n\r\n            return new BMap.Pixel(clientX, clientY);\r\n        }\r\n\r\n        var map = this._map,\r\n            me = this,\r\n            pixel = map.pointToPixel(this.getDrawPoint(e)),\r\n            clientPos = getClientPosition(e),\r\n            offsetX = clientPos.x - pixel.x,\r\n            offsetY = clientPos.y - pixel.y;\r\n        pixel = new BMap.Pixel((clientPos.x - offsetX), (clientPos.y - offsetY));\r\n        this._draggingMovePixel = pixel;\r\n        var point = map.pixelToPoint(pixel),\r\n            eventObj = {\r\n                pixel: pixel,\r\n                point: point\r\n            };\r\n        // 拖拽到地图边缘移动地图\r\n        this._panByX = this._panByY = 0;\r\n        if (pixel.x <= 20 || pixel.x >= map.width - 20 ||\r\n            pixel.y <= 50 || pixel.y >= map.height - 10) {\r\n            if (pixel.x <= 20) {\r\n                this._panByX = 8;\r\n            }\r\n            else if (pixel.x >= map.width - 20) {\r\n                this._panByX = -8;\r\n            }\r\n\r\n            if (pixel.y <= 50) {\r\n                this._panByY = 8;\r\n            }\r\n            else if (pixel.y >= map.height - 10) {\r\n                this._panByY = -8;\r\n            }\r\n\r\n            if (!this._edgeMoveTimer) {\r\n                this._edgeMoveTimer = setInterval(function () {\r\n                    map.panBy(me._panByX, me._panByY, {\r\n                        noAnimation: true\r\n                    });\r\n                }, 30);\r\n            }\r\n        } else {\r\n            if (this._edgeMoveTimer) {\r\n                clearInterval(this._edgeMoveTimer);\r\n                this._edgeMoveTimer = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * 调整大小\r\n     * @param {Size}\r\n     */\r\n    Mask.prototype._adjustSize = function (size) {\r\n        this.container.style.width = size.width + 'px';\r\n        this.container.style.height = size.height + 'px';\r\n    };\r\n\r\n    /**\r\n     * 获取当前绘制点的地理坐标\r\n     *\r\n     * @param {Event} e e对象\r\n     * @return Point对象的位置信息\r\n     */\r\n    Mask.prototype.getDrawPoint = function (e) {\r\n\r\n        var map = this._map,\r\n            trigger = baidu.getTarget(e),\r\n            x = e.offsetX || e.layerX || 0,\r\n            y = e.offsetY || e.layerY || 0;\r\n        if (trigger.nodeType != 1) {\r\n            trigger = trigger.parentNode;\r\n        }\r\n\r\n        while (trigger && trigger != map.getContainer()) {\r\n            if (!(trigger.clientWidth == 0 &&\r\n                trigger.clientHeight == 0 &&\r\n                trigger.offsetParent && trigger.offsetParent.nodeName == 'TD')) {\r\n                x += trigger.offsetLeft || 0;\r\n                y += trigger.offsetTop || 0;\r\n            }\r\n\r\n            trigger = trigger.offsetParent;\r\n        }\r\n        var pixel = new BMap.Pixel(x, y);\r\n        var point = map.pixelToPoint(pixel);\r\n        return point;\r\n\r\n    };\r\n\r\n    /**\r\n     * 绘制工具面板，自定义控件\r\n     */\r\n    function DrawingTool(drawingManager, drawingToolOptions) {\r\n        this.drawingManager = drawingManager;\r\n\r\n        drawingToolOptions = this.drawingToolOptions = drawingToolOptions || {};\r\n        this._opts = {};\r\n        // 默认停靠位置和偏移量\r\n        this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT;\r\n        this.defaultOffset = new BMap.Size(10, 10);\r\n\r\n        // 默认所有工具栏都显示\r\n        this.defaultDrawingModes = [\r\n            BMAP_DRAWING_MARKER,\r\n            BMAP_DRAWING_CIRCLE,\r\n            BMAP_DRAWING_POLYLINE,\r\n            BMAP_DRAWING_POLYGON,\r\n            BMAP_DRAWING_RECTANGLE\r\n        ];\r\n        // 工具栏可显示的绘制模式\r\n        if (drawingToolOptions.drawingModes) {\r\n            this.drawingModes = drawingToolOptions.drawingModes;\r\n        } else {\r\n            this.drawingModes = this.defaultDrawingModes;\r\n        }\r\n\r\n        // 用户设置停靠位置和偏移量\r\n        if (drawingToolOptions.hasCustomStyle) {\r\n            if (drawingToolOptions.anchor) {\r\n                this.setAnchor(drawingToolOptions.anchor);\r\n            }\r\n\r\n            if (drawingToolOptions.offset) {\r\n                this.setOffset(drawingToolOptions.offset);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 通过JavaScript的prototype属性继承于BMap.Control\r\n    DrawingTool.prototype = new BMap.Control();\r\n\r\n    // 自定义控件必须实现自己的initialize方法,并且将控件的DOM元素返回\r\n    // 在本方法中创建个div元素作为控件的容器,并将其添加到地图容器中\r\n    DrawingTool.prototype.initialize = function (map) {\r\n        // 创建一个DOM元素\r\n        var container = this.container = document.createElement('div');\r\n        container.className = 'BMapGLLib_Drawing';\r\n        // 用来设置外层边框阴影\r\n        var panel = this.panel = document.createElement('div');\r\n        panel.className = 'BMapGLLib_Drawing_panel';\r\n        if (this.drawingToolOptions && this.drawingToolOptions.hasCustomStyle && this.drawingToolOptions.scale) {\r\n            this._setScale(this.drawingToolOptions.scale);\r\n        }\r\n\r\n        container.appendChild(panel);\r\n        // 添加内容\r\n        var content = this._generalHtml();\r\n        panel.appendChild(content);\r\n        // 添加tip\r\n        var tip = this.tip = document.createElement('div');\r\n        tip.className = 'BMapGLLib_tip';\r\n        tip.innerHTML = '<p class=\"BMapGLLib_tip_title\"></p><p class=\"BMapGLLib_tip_text\"></p>';\r\n        if (this.drawingToolOptions.enableTips === true) {\r\n            panel.appendChild(tip);\r\n        }\r\n        // 绑定事件\r\n        this._bind(panel);\r\n        // 添加DOM元素到地图中\r\n        if (this.drawingToolOptions.customContainer) {\r\n            baidu.g(this.drawingToolOptions.customContainer).appendChild(container);\r\n        } else {\r\n            map.getContainer().appendChild(container);\r\n        }\r\n        // 将DOM元素返回\r\n        return container;\r\n    };\r\n\r\n    // 生成工具栏的html元素\r\n    DrawingTool.prototype._generalHtml = function (map) {\r\n        var that = this;\r\n        // 鼠标经过工具栏上的提示信息\r\n        var tips = {};\r\n        tips.hander = '拖动地图';\r\n        tips[BMAP_DRAWING_MARKER] = '画点';\r\n        tips[BMAP_DRAWING_CIRCLE] = '圆形工具';\r\n        tips[BMAP_DRAWING_POLYLINE] = '画折线';\r\n        tips[BMAP_DRAWING_POLYGON] = '多边形工具';\r\n        tips[BMAP_DRAWING_RECTANGLE] = '矩形工具';\r\n\r\n        var getItem = function (className, drawingType) {\r\n            var ele = document.createElement('a');\r\n            ele.className = className;\r\n            ele.href = 'javascript:void(0)';\r\n            ele.setAttribute('drawingType', drawingType);\r\n            ele.setAttribute('onfocus', 'this.blur()');\r\n            ele.addEventListener('mouseenter', function (e) {\r\n                var drawingType = e.target.getAttribute('drawingType');\r\n                var title = tips[drawingType];\r\n                if (drawingType === 'hander') {\r\n                    that.tip.children[0].innerText = title;\r\n                    that.tip.children[1].innerText = '使用鼠标拖动地图';\r\n                } else {\r\n                    that.tip.className += ' ' + drawingType;\r\n                    that.tip.children[0].innerText = title;\r\n                    that.tip.children[1].innerText = '使用' + title + '选出目标区域';\r\n                }\r\n                that.tip.style.display = 'block';\r\n            });\r\n            ele.addEventListener('mouseleave', function (e) {\r\n                // remove class drawingType\r\n                var drawingType = e.target.getAttribute('drawingType');\r\n                var newClass = ' ' + that.tip.className.replace(/[\\t\\r\\n]/g, '') + ' ';\r\n                while (newClass.indexOf(' ' + drawingType + ' ') >= 0) {\r\n                    newClass = newClass.replace(' ' + drawingType + ' ', ' ');\r\n                }\r\n                that.tip.className = newClass.replace(/^\\s+|\\s+$/g, '');\r\n\r\n                that.tip.style.display = 'none';\r\n            });\r\n            return ele;\r\n        };\r\n\r\n        // 生成工具\r\n        var fragment = document.createDocumentFragment();\r\n        // 取消hander工具的展示，交互改为再次点击tool取消active功能\r\n        // fragment.appendChild(getItem('BMapGLLib_box BMapGLLib_hander', 'hander'));\r\n        for (var i = 0, len = this.drawingModes.length; i < len; i++) {\r\n            var classStr = 'BMapGLLib_box BMapGLLib_' + this.drawingModes[i];\r\n            if (i == len - 1) {\r\n                classStr += ' BMapGLLib_last';\r\n            }\r\n\r\n            fragment.appendChild(getItem(classStr, this.drawingModes[i]));\r\n        }\r\n\r\n        return fragment;\r\n    };\r\n\r\n    /**\r\n     * 设置工具栏的缩放比例\r\n     */\r\n    DrawingTool.prototype._setScale = function (scale) {\r\n        var width = 390,\r\n            height = 50,\r\n            ml = -parseInt((width - width * scale) / 2, 10),\r\n            mt = -parseInt((height - height * scale) / 2, 10);\r\n        this.container.style.cssText = [\r\n            '-moz-transform: scale(' + scale + ');',\r\n            '-o-transform: scale(' + scale + ');',\r\n            '-webkit-transform: scale(' + scale + ');',\r\n            'transform: scale(' + scale + ');',\r\n            'margin-left:' + ml + 'px;',\r\n            'margin-top:' + mt + 'px;',\r\n            '*margin-left:0px;', // ie6、7\r\n            '*margin-top:0px;', // ie6、7\r\n            'margin-left:0px\\\\0;', // ie8\r\n            'margin-top:0px\\\\0;', // ie8\r\n            // ie下使用滤镜\r\n            'filter: progid:DXImageTransform.Microsoft.Matrix(',\r\n            'M11=' + scale + ',',\r\n            'M12=0,',\r\n            'M21=0,',\r\n            'M22=' + scale + ',',\r\n            'SizingMethod=\\'auto expand\\');'\r\n        ].join('');\r\n    };\r\n\r\n    // 绑定工具栏的事件\r\n    DrawingTool.prototype._bind = function (panel) {\r\n        var me = this;\r\n        baidu.on(this.panel, 'click', function (e) {\r\n            var target = baidu.getTarget(e);\r\n            var drawingType = target.getAttribute('drawingType');\r\n            me.setStyleByDrawingMode(drawingType);\r\n            me._bindEventByDraingMode(drawingType);\r\n        });\r\n    };\r\n\r\n    // 设置工具栏当前选中的项样式\r\n    DrawingTool.prototype.setStyleByDrawingMode = function (drawingType) {\r\n        if (!drawingType) {\r\n            return;\r\n        }\r\n\r\n        var boxs = this.panel.getElementsByTagName('a');\r\n        for (var i = 0, len = boxs.length; i < len; i++) {\r\n            var box = boxs[i];\r\n            if (box.getAttribute('drawingType') == drawingType) {\r\n                var classStr = 'BMapGLLib_box BMapGLLib_' + drawingType + '_hover';\r\n                if (i == len - 1) {\r\n                    classStr += ' BMapGLLib_last';\r\n                }\r\n\r\n                box.className = classStr;\r\n            } else {\r\n                box.className = box.className.replace(/_hover/, '');\r\n            }\r\n        }\r\n    };\r\n\r\n    // 设置工具栏当前选中的项样式\r\n    DrawingTool.prototype._bindEventByDraingMode = function (drawingType) {\r\n        var me = this;\r\n        var drawingManager = this.drawingManager;\r\n        // 点在拖拽地图的按钮上\r\n        // hander工具的逻辑\r\n        // if (drawingType == 'hander') {\r\n        //     drawingManager.close();\r\n        //     drawingManager._map.enableDoubleClickZoom();\r\n        // }\r\n        // else {\r\n        //     drawingManager.setDrawingMode(drawingType);\r\n        //     drawingManager.open();\r\n        //     drawingManager._map.disableDoubleClickZoom();\r\n        // }\r\n\r\n        // 关闭hander工具的逻辑\r\n        if (drawingManager._isOpen && drawingManager.getDrawingMode() === drawingType) {\r\n            drawingManager.close();\r\n            drawingManager._map.enableDoubleClickZoom();\r\n        } else {\r\n            drawingManager.setDrawingMode(drawingType);\r\n            drawingManager.open();\r\n            drawingManager._map.disableDoubleClickZoom();\r\n        }\r\n    };\r\n\r\n\r\n    /*\r\n     * 关闭其他实例的绘制模式\r\n     * @param {DrawingManager} 当前的实例\r\n     */\r\n    function closeInstanceExcept(instance) {\r\n        var index = instances.length;\r\n        while (index--) {\r\n            if (instances[index] != instance) {\r\n                instances[index].close();\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function drawcircle(center, radius) {\r\n        var points = [];\r\n        var cx = center[\"lng\"],\r\n            cy = center[\"lat\"];\r\n        var d = radius / 6378800, // circle radius / meters of Earth radius = radians\r\n            lat1 = (Math.PI / 180) * cy,\r\n            lng1 = (Math.PI / 180) * cx;\r\n\r\n        for (var i = 0; i < 271; i += 9) {\r\n            var tc = (Math.PI / 180) * i,\r\n                y = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(tc)),\r\n                dlng = Math.atan2(Math.sin(tc) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(y)),\r\n                x = ((lng1 - dlng + Math.PI) % (2 * Math.PI)) - Math.PI,\r\n                point = new BMap.Point(x * (180 / Math.PI), y * (180 / Math.PI));\r\n            points.push(point);\r\n        }\r\n\r\n        var fstPoint = points[0];\r\n        points.push(new BMap.Point(fstPoint[\"lng\"], fstPoint[\"lat\"]));\r\n        return points;\r\n    }\r\n\r\n    function getPointByDistance(srcPoint, distance, direction) {\r\n        var cx = srcPoint[\"lng\"],\r\n            cy = srcPoint[\"lat\"];\r\n        var d = distance / 6378800, // circle radius / meters of Earth radius = radians\r\n            lat1 = (Math.PI / 180) * cy,\r\n            lng1 = (Math.PI / 180) * cx;\r\n        var i, tmplng, tmplat;\r\n        switch (direction) {\r\n            case 'North':\r\n            case 'north':\r\n            case 'N':\r\n            case 'n':\r\n                i = 0;\r\n                tmplng = srcPoint.lng;\r\n                break;\r\n            case 'West':\r\n            case 'west':\r\n            case 'W':\r\n            case 'w':\r\n                i = 90;\r\n                tmplat = srcPoint.lat;\r\n                break;\r\n            case 'South':\r\n            case 'south':\r\n            case 'S':\r\n            case 's':\r\n                i = 180;\r\n                tmplng = srcPoint.lng;\r\n                break;\r\n            case 'East':\r\n            case 'east':\r\n            case 'E':\r\n            case 'e':\r\n                i = 270;\r\n                tmplat = srcPoint.lat;\r\n                break;\r\n            default:\r\n                i = ~~direction;\r\n                break;\r\n        }\r\n        var tc = (Math.PI / 180) * i,\r\n            y = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(tc)),\r\n            dlng = Math.atan2(Math.sin(tc) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(y)),\r\n            x = ((lng1 - dlng + Math.PI) % (2 * Math.PI)) - Math.PI,\r\n            point = new BMap.Point(tmplng || x * (180 / Math.PI), tmplat || y * (180 / Math.PI));\r\n        point.lng = parseFloat(point.lng.toFixed(6));\r\n        point.lat = parseFloat(point.lat.toFixed(6));\r\n        return point;\r\n    }\r\n\r\n})();\r\n\n\n//# sourceURL=webpack:///./src/DrawingManager.min.js?");

/***/ })

}]);